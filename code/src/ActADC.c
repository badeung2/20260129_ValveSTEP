#include "AppBuild.h"
#include "ActADC.h"
#include "drivelib/ErrorCodes.h"
#include "drivelib/NV_UserPage.h"
#if (_APP_BURN_IN != FALSE) || (_APP_DMA_STRESS_TEST != FALSE) || (_DEBUG_RESOLVER != FALSE) || \
(_SUPPORT_TRIAXIS_MLX9038x != FALSE) || (_SUPPORT_STALLDET_BZC != FALSE)
#include "drivelib/GlobalVars.h"
#endif
#include "drivelib/MotorDriver.h"
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE) || (_SUPPORT_STALLDET_LA != FALSE) || ((_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDENT_GND) && (_SUPPORT_PWM_MODE != BIPOLAR_FULL_STEP_BEMF) && (_SUPPORT_PWM_MODE != BIPOLAR_HALF_STEP_BEMF) && (_SUPPORT_APP_TYPE != C_APP_SOLENOID) && (_SUPPORT_PWM_MODE != SINGLE_COIL_PWM))
#include "drivelib/MotorDriverTables.h"
#endif
#include "camculib/private_mathlib.h"
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
#include "senselib/Triaxis_MLX9038x.h"
#endif
#include <sys_tools.h>
#if (_SUPPORT_STALLDET_BZC != FALSE)
#define C_MIN_HCOMMUT_TIME 75
#define C_MAX_HCOMMUT_TIME 16383
#if (_SUPPORT_ADC_REF_HV_CALIB == FALSE)
#define C_1VOLT 19U
#define C_100MV 2U
#else
#define C_1VOLT 32U
#define C_100MV 3U
#endif
#endif
#pragma space dp
#if (C_MOTOR_PHASES != 1)
int16_t g_i16MotorCurrentCoilA = 0;
#if (_SUPPORT_PWM_MODE != BIPOLAR_FULL_STEP_BEMF) && (_SUPPORT_PWM_MODE != BIPOLAR_HALF_STEP_BEMF)
int16_t g_i16MotorCurrentCoilB = 0;
#if (C_MOTOR_PHASES == 3)
int16_t g_i16MotorCurrentCoilC = 0;
int16_t g_i16MotorCurrentCoilY = 0;
#endif
#endif
#endif
uint16_t g_u16MotorCurrentPeak = 0U;
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE) || (_SUPPORT_STALLDET_LA != FALSE)
int16_t g_i16MotorCurrentAngle = 0;
#endif
#if (_SUPPORT_STALLDET_BRI != FALSE)
uint32_t l_u32MotorBemfVoltage_Integration = 0U;
uint16_t l_u16MotorBemf_IntegrationCount = 0U;
uint16_t l_u16MotorBemf_IgnoreCount = 0U;
uint16_t g_u16MotorBemfVoltage = 0U;
#endif
#if (ANA_COMM != FALSE)
uint16_t g_u16ReferencePotiPos;
#endif
#pragma space none
#pragma space nodp
volatile ADC_RESULTS l_AdcResult;
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE) && (_SUPPORT_VARIABLE_PWM != FALSE)
volatile ADC_RESULTS_3 l_AdcResult3;
#endif
#if (_SUPPORT_STALLDET_BZC != FALSE)
volatile ADC_MOTORRUN_BEMF l_AdcMotorRunBemf;
uint16_t l_u16FullStepIndex = 0U;
uint16_t l_u16ZeroCrossVoltage = 0U;
uint16_t l_u16ZcTime = 0U;
#endif
#if (ANA_COMM != FALSE)
static uint16_t l_au16PosRefSamples[C_POS_MOVAVG_SZ] = {0U};
static uint16_t l_u16PosRefMovAgvIdx = 0U;
static uint16_t l_u16PosRefMovAvgxN = 0U;
#endif
#if (_SUPPORT_POTI != FALSE)
static uint16_t l_au16PosActSamples[C_POS_MOVAVG_SZ] = {0};
static uint16_t l_u16PosActMovAgvIdx = 0U;
static uint16_t l_u16PosActMovAvgxN = 0U;
#endif
#pragma space none
#if (_SUPPORT_STALLDET_BRI != FALSE)
extern int16_t GetRawMotorBemfVoltage(void);
#endif
static ADC_SDATA_t const SBASE_MOTOR_RUN[] =
{
#if (_SUPPORT_APP_TYPE == C_APP_SOLENOID)
C_ADC_VS_MSTR1_CMP,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_MCUR_SLV2,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#else
#if (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM)
C_ADC_VS_MSTR1_CMP,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_MCURF,
.u3AdcVref = C_ADC_VREF_MCUR,
.u5AdcTrigger = C_ADC_HW_TRIGGER_SLV2_CMP,
.u1AdcReserved = 0U
}
},
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_MCURF,
.u3AdcVref = C_ADC_VREF_MCUR,
.u5AdcTrigger = C_ADC_HW_TRIGGER_SLV3_CMP,
.u1AdcReserved = 0U
}
},
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_POTI != FALSE)
C_ADC_POTI_IOX_EOC,
#elif (_SUPPORT_IO_DUT_SELECT_HVIO != FALSE) && (HVIO_DUT_SELECT == PIN_FUNC_IO_0)
C_ADC_IO0_HV_EOC,
#endif
C_ADC_VS_EOC,
#if (_SUPPORT_IO_CMD_SELECT_LVIO != FALSE)
#if (HVIO_DUT_SELECT_A == PIN_FUNC_IO_0)
C_ADC_IO0_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_1)
C_ADC_IO1_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_2)
C_ADC_IO2_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_3)
C_ADC_IO3_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_4)
C_ADC_IO4_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_5)
C_ADC_IO5_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_6)
C_ADC_IO6_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_7)
C_ADC_IO7_LV_EOC,
#endif
#if (_SUPPORT_NR_OF_IO_SELECT >= 2U)
#if (HVIO_DUT_SELECT_B == PIN_FUNC_IO_1)
C_ADC_IO1_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_2)
C_ADC_IO2_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_3)
C_ADC_IO3_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_4)
C_ADC_IO4_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_5)
C_ADC_IO5_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_6)
C_ADC_IO6_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_7)
C_ADC_IO7_LV_EOC,
#endif
#if (_SUPPORT_NR_OF_IO_SELECT >= 3U)
#if (HVIO_DUT_SELECT_C == PIN_FUNC_IO_2)
C_ADC_IO2_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_3)
C_ADC_IO3_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_4)
C_ADC_IO4_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_5)
C_ADC_IO5_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_6)
C_ADC_IO6_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_7)
C_ADC_IO7_LV_EOC,
#endif
#endif
#endif
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_MCURF,
.u3AdcVref = C_ADC_VREF_MCUR,
.u5AdcTrigger = C_ADC_HW_TRIGGER_SLV2_CMP,
.u1AdcReserved = 0U
}
},
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_MCURF,
.u3AdcVref = C_ADC_VREF_MCUR,
.u5AdcTrigger = C_ADC_HW_TRIGGER_SLV3_CMP,
.u1AdcReserved = 0U
}
},
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC
#if (ANA_COMM != FALSE) && (C_ANA_IO == PIN_FUNC_IO_0)
C_ADC_IO0_HV_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM_BIPOLAR)
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VS_MSTR1_CMP,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_MCUR_SLV2,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#else
C_ADC_VS_MSTR1_CMP,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_SLV2,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == BIPOLAR_FULL_STEP_BEMF) || (_SUPPORT_PWM_MODE == BIPOLAR_HALF_STEP_BEMF)
C_ADC_VS_MSTR1_CMP,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#if (_SUPPORT_STALLDET_BRI != FALSE)
C_ADC_VPHU_EOC,
#endif
C_ADC_MCUR_SLV2,
#if (_SUPPORT_STALLDET_BRI != FALSE)
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_WT) || (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_TW)
C_ADC_VPHV_EOC,
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
C_ADC_VPHW_EOC,
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW)
C_ADC_VPHT_EOC,
#else
#error "ERROR: Bi-Polar Full-step not implemented"
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#elif (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDENT_GND)
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VS_MSTR1_CMP,
C_ADC_VSMF_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#else
C_ADC_TEMP_EOC,
#endif
C_ADC_MCUR_SLV2,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_TEMP_EOC,
C_ADC_VDDA_EOC,
#else
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
C_ADC_MCUR_MSTR2
#else
C_ADC_VS_MSTR1_CMP,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#else
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_SLV2,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_MCUR_MSTR2
#endif
#elif (_SUPPORT_PWM_MODE == BIPOLAR_TRIPHASE_ALLPWM_MIRROR)
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE)
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_SW)
C_ADC_VS_EOC,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_SLV1,
#else
C_ADC_VS_MSTR1_CMP,
C_ADC_MCUR_SLV1,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_MCUR_SLV2,
#else
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_SW)
C_ADC_VS_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_SLV1,
#else
C_ADC_VS_MSTR1_CMP,
C_ADC_MCUR_SLV1,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_MCUR_SLV2,
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_ALLPWM_MIRROR)
#if (_SUPPORT_STALLDET_BZC != FALSE)
C_ADC_VS_MSTR1_CMP,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_MCUR_SLV3,
#elif (_SUPPORT_FOC_MODE != FOC_MODE_NONE)
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_SW)
C_ADC_VS_EOC,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_SLV1,
#else
C_ADC_VS_MSTR1_CMP,
C_ADC_MCUR_SLV1,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_MCUR_SLV2,
#else
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_SW)
C_ADC_VS_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_SLV1,
#else
C_ADC_VS_MSTR1_CMP,
C_ADC_MCUR_SLV1,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_MCUR_SLV2,
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_MIRROR_SUP)
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VS_MSTR1_CMP,
C_ADC_VSMF_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
C_ADC_TEMP_EOC,
C_ADC_VDDA_EOC,
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#else
C_ADC_TEMP_EOC,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#endif
#else
C_ADC_VS_MSTR1_CMP,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#endif
C_ADC_MCUR_MSTR2
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_MIRROR_GND)
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VS_MSTR1_CMP,
C_ADC_VSMF_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#else
C_ADC_TEMP_EOC,
#endif
C_ADC_MCUR_SLV2,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_TEMP_EOC,
C_ADC_VDDA_EOC,
#else
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#else
C_ADC_VS_MSTR1_CMP,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_MCUR_SLV2,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#endif
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_INDEPENDENT_GND) || \
(_SUPPORT_PWM_MODE == BIPOLAR_TRIPHASE_TWOPWM_INDEPENDENT_GND)
#if (_SUPPORT_ADC_BGD != FALSE)
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_VS_HV,
.u3AdcVref = C_ADC_VREF_HV,
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR1_CMP,
.u1AdcReserved = 0U
}
},
C_ADC_VSMF_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#else
C_ADC_TEMP_EOC,
#if (ANA_COMM != FALSE) && (C_ANA_IO == PIN_FUNC_IO_4)
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_IO4_LV,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
#elif (_SUPPORT_IO_DUT_SELECT_HVIO != FALSE) && (HVIO_DUT_SELECT == PIN_FUNC_IO_0)
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_IO0_HV,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
#endif
#endif
C_ADC_MCUR_SLV2,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_TEMP_EOC,
#if (_SUPPORT_RESOLVER2_X_IO != PIN_FUNC_IO_NONE) && (_SUPPORT_RESOLVER2_Y_IO != PIN_FUNC_IO_NONE)
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_IO2_LV,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_IO3_LV,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
#else
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#endif
#endif
#else
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#endif
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_MCUR,
.u3AdcVref = C_ADC_VREF_MCUR,
#if (_SUPPORT_ADC_PWM_DELAY != FALSE)
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR2_CMP,
#else
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR1_CNT,
#endif
.u1AdcReserved = 0U
}
}
#else
C_ADC_VS_MSTR1_CMP,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_SLV2,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
#if (_SUPPORT_RESOLVER2_X_IO != PIN_FUNC_IO_NONE) && (_SUPPORT_RESOLVER2_Y_IO != PIN_FUNC_IO_NONE)
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_IO2_LV,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_IO3_LV,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
#elif (ANA_COMM != FALSE) && (C_ANA_IO == PIN_FUNC_IO_4)
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_IO4_LV,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
#elif (_SUPPORT_IO_DUT_SELECT_HVIO != FALSE) && (HVIO_DUT_SELECT == PIN_FUNC_IO_0)
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_IO0_HV,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
#elif (_SUPPORT_NTC != FALSE)
C_ADC_NTC_IO_LV_EOC,
#elif (_SUPPORT_POTI != FALSE)
C_ADC_POTI_IOX_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_MCUR,
#if !defined (__MLX81339__) && !defined (__MLX81350__)
.u3AdcVref = C_ADC_VREF_MCUR,
#else
.u3AdcReserved = 0U,
#endif
#if (_SUPPORT_ADC_PWM_DELAY != FALSE)
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR2_CMP,
#else
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR1_CNT,
#endif
.u1AdcReserved = 0U
}
}
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_FULL_STEP_BEMF)
C_ADC_VS_MSTR1_CMP,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_MCUR_SLV2,
#if (_SUPPORT_STALLDET_BRI != FALSE)
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_PH_U_HV,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#endif
#endif
};
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE) && (_SUPPORT_VARIABLE_PWM != FALSE)
static const ADC_SDATA_t SBASE_INIT_3PWM[] =
{
{.u16 = (uint16_t)&l_AdcResult3.u16AdcVs},
C_ADC_VS_MSTR1_CMP,
C_ADC_MCUR_SLV1,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VBGD_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_VDDD,
.u3AdcVref = C_ADC_VREF_2_50_V,
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
#endif
C_ADC_MCUR_SLV3,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_ADC_VBOOST != FALSE)
C_ADC_VBOOST_EOC,
#endif
C_ADC_MCUR_MSTR2
};
#endif
static ADC_SDATA_t const SBASE_MOTOR_IDLE[] =
{
#if (_SUPPORT_APP_TYPE == C_APP_SOLENOID)
C_ADC_VS_EOC,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_MCUR_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#else
#if (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM)
C_ADC_VS_EOC,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_MCUR_EOC,
C_ADC_MCUR_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_POTI != FALSE)
C_ADC_POTI_IOX_EOC,
#elif (_SUPPORT_IO_DUT_SELECT_HVIO != FALSE) && (HVIO_DUT_SELECT == PIN_FUNC_IO_0)
C_ADC_IO0_HV_EOC,
#endif
C_ADC_VS_EOC,
#if (_SUPPORT_IO_CMD_SELECT_LVIO != FALSE)
#if (HVIO_DUT_SELECT_A == PIN_FUNC_IO_0)
C_ADC_IO0_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_1)
C_ADC_IO1_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_2)
C_ADC_IO2_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_3)
C_ADC_IO3_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_4)
C_ADC_IO4_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_5)
C_ADC_IO5_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_6)
C_ADC_IO6_LV_EOC,
#elif (HVIO_DUT_SELECT_A == PIN_FUNC_IO_7)
C_ADC_IO7_LV_EOC,
#endif
#if (_SUPPORT_NR_OF_IO_SELECT >= 2U)
#if (HVIO_DUT_SELECT_B == PIN_FUNC_IO_1)
C_ADC_IO1_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_2)
C_ADC_IO2_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_3)
C_ADC_IO3_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_4)
C_ADC_IO4_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_5)
C_ADC_IO5_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_6)
C_ADC_IO6_LV_EOC,
#elif (HVIO_DUT_SELECT_B == PIN_FUNC_IO_7)
C_ADC_IO7_LV_EOC,
#endif
#if (_SUPPORT_NR_OF_IO_SELECT >= 3U)
#if (HVIO_DUT_SELECT_C == PIN_FUNC_IO_2)
C_ADC_IO2_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_3)
C_ADC_IO3_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_4)
C_ADC_IO4_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_5)
C_ADC_IO5_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_6)
C_ADC_IO6_LV_EOC,
#elif (HVIO_DUT_SELECT_C == PIN_FUNC_IO_7)
C_ADC_IO7_LV_EOC,
#endif
#endif
#endif
#endif
C_ADC_MCUR_EOC,
C_ADC_MCUR_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC
#if (ANA_COMM != FALSE) && (C_ANA_IO == PIN_FUNC_IO_0)
C_ADC_IO0_HV_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM_BIPOLAR)
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VS_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_MCUR_EOC,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#else
C_ADC_VS_EOC,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == BIPOLAR_FULL_STEP_BEMF) || (_SUPPORT_PWM_MODE == BIPOLAR_HALF_STEP_BEMF)
C_ADC_VS_EOC,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#if (_SUPPORT_STALLDET_BRI != FALSE)
C_ADC_VPHU_EOC,
#endif
C_ADC_MCUR_EOC,
#if (_SUPPORT_STALLDET_BRI != FALSE)
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_WT) || (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_TW)
C_ADC_VPHV_EOC,
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
C_ADC_VPHW_EOC,
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW)
C_ADC_VPHT_EOC,
#else
#error "ERROR: Bi-Polar Full-step not implemented"
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#elif (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDENT_GND)
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VS_EOC,
C_ADC_VSMF_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#else
C_ADC_TEMP_EOC,
#endif
C_ADC_MCUR_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_TEMP_EOC,
C_ADC_VDDA_EOC,
#else
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#else
C_ADC_VS_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#else
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == BIPOLAR_TRIPHASE_ALLPWM_MIRROR)
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE)
C_ADC_VS_EOC,
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_SW)
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_EOC,
#else
C_ADC_MCUR_EOC,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#else
C_ADC_VS_EOC,
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_SW)
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_EOC,
#else
C_ADC_MCUR_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_ALLPWM_MIRROR)
#if (_SUPPORT_STALLDET_BZC != FALSE)
C_ADC_VS_EOC,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#if (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_MIRROR_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDENT_GND)
C_ADC_MCUR_EOC,
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_MCUR_EOC,
#elif (_SUPPORT_FOC_MODE != FOC_MODE_NONE)
C_ADC_VS_EOC,
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_SW)
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_EOC,
#else
C_ADC_MCUR_EOC,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#else
C_ADC_VS_EOC,
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_SW)
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_EOC,
#else
C_ADC_MCUR_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE) && (_SUPPORT_PWM_ADC_TRIGGER_MODE == ADC_TRIGGER_PWM_MIN_MAX)
C_ADC_VDDA_EOC,
#endif
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_MIRROR_SUP)
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VS_EOC,
C_ADC_VSMF_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
C_ADC_TEMP_EOC,
C_ADC_VDDA_EOC,
#else
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#else
C_ADC_VS_EOC,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#endif
C_ADC_MCUR_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_MIRROR_GND)
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VS_EOC,
C_ADC_VSMF_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#else
C_ADC_TEMP_EOC,
#endif
C_ADC_MCUR_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_TEMP_EOC,
C_ADC_VDDA_EOC,
#else
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#else
C_ADC_VS_EOC,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_MCUR_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_INDEPENDENT_GND)
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VS_EOC,
C_ADC_VSMF_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#else
C_ADC_TEMP_EOC,
#if (ANA_COMM != FALSE) && (C_ANA_IO == PIN_FUNC_IO_4)
C_ADC_IO4_LV_EOC,
#elif (_SUPPORT_IO_DUT_SELECT_HVIO != FALSE) && (HVIO_DUT_SELECT == PIN_FUNC_IO_0)
C_ADC_IO0_HV_EOC,
#endif
#endif
C_ADC_MCUR_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_TEMP_EOC,
#if (_SUPPORT_RESOLVER2_X_IO != PIN_FUNC_IO_NONE) && (_SUPPORT_RESOLVER2_Y_IO != PIN_FUNC_IO_NONE)
C_ADC_IO2_LV_EOC,
C_ADC_IO3_LV_EOC,
#else
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#endif
#endif
#else
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_VAUX_EOC,
C_ADC_VBGD_EOC,
#endif
#endif
#else
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_VS_HV,
#if !defined (__MLX81339__) && !defined (__MLX81350__)
.u3AdcVref = C_ADC_VREF_HV,
#else
.u3AdcReserved = 0U,
#endif
.u5AdcTrigger = C_ADC_HW_TRIGGER_EOCplsNxADC_CLOCK,
.u1AdcReserved = 0U
}
},
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
C_ADC_MCUR_EOC,
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
#if (_SUPPORT_RESOLVER2_X_IO != PIN_FUNC_IO_NONE) && (_SUPPORT_RESOLVER2_Y_IO != PIN_FUNC_IO_NONE)
C_ADC_IO2_LV_EOC,
C_ADC_IO3_LV_EOC,
#elif (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
#endif
#elif (ANA_COMM != FALSE) && (C_ANA_IO == PIN_FUNC_IO_4)
C_ADC_IO4_LV_EOC,
#elif (_SUPPORT_IO_DUT_SELECT_HVIO != FALSE) && (HVIO_DUT_SELECT == PIN_FUNC_IO_0)
C_ADC_IO0_HV_EOC,
#elif (_SUPPORT_NTC != FALSE)
C_ADC_NTC_IO_LV_EOC,
#elif (_SUPPORT_POTI != FALSE)
C_ADC_POTI_IOX_EOC,
#endif
C_ADC_MCUR_EOC,
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_FULL_STEP_BEMF)
C_ADC_VS_EOC,
C_ADC_VDDA_EOC,
C_ADC_VDDD_EOC,
C_ADC_MCUR_EOC,
#if (_SUPPORT_STALLDET_BRI != FALSE)
C_ADC_VPHU_EOC,
#endif
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
#endif
#endif
};
#if (_SUPPORT_PWM_MODE == TRIPLEPHASE_FULL_STEP_BEMF) || (_SUPPORT_PWM_MODE == BIPOLAR_FULL_STEP_BEMF)
void ADC_Start(uint16_t u16FullStep, uint16_t u16IrqEna)
#elif (_SUPPORT_PWM_MODE == BIPOLAR_HALF_STEP_BEMF)
void ADC_Start(uint16_t u16HalfStep, uint16_t u16IrqEna)
#else
void ADC_Start(uint16_t u16IrqEna)
#endif
{
#if ((_SUPPORT_PWM_MODE == TRIPLEPHASE_FULL_STEP_BEMF) || (_SUPPORT_PWM_MODE == BIPOLAR_FULL_STEP_BEMF)) && (_SUPPORT_STALLDET_BZC != FALSE)
(void) u16FullStep;
if (l_u8AdcMode != C_ADC_MODE_ON_STEPPER)
#elif (_SUPPORT_PWM_MODE == BIPOLAR_HALF_STEP_BEMF) && (_SUPPORT_STALLDET_BZC != FALSE)
(void) u16HalfStep;
if (l_u8AdcMode != C_ADC_MODE_ON_STEPPER)
#else
if (l_u8AdcMode != C_ADC_MODE_RUN_HW)
#endif
{
HAL_ADC_StopSafe();
{
uint16_t *pu16Src = &l_au16AdcSource[0];
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE) && (_SUPPORT_VARIABLE_PWM != FALSE)
if (g_u8TriplePWM != FALSE)
{
uint16_t *pu16SBase = (uint16_t *)&SBASE_INIT_3PWM[0];
do
{
*pu16Src = *pu16SBase;
pu16Src++;
pu16SBase++;
} while (pu16SBase < &SBASE_INIT_3PWM[sizeof(SBASE_INIT_3PWM) / sizeof(uint16_t)]);
}
else
#endif
{
uint16_t *pu16SBase = (uint16_t *)&SBASE_MOTOR_RUN[0];
*pu16Src++ = (uint16_t)&l_AdcResult;
pu16Src = p_MemCpyU16(pu16Src, pu16SBase, (sizeof(SBASE_MOTOR_RUN) / sizeof(uint16_t)));
}
*pu16Src++ = C_ADC_EOF;
*pu16Src = (uint16_t)&l_au16AdcSource[0];
#if (_SUPPORT_STALLDET_BRI != FALSE)
#if (C_MOTOR_COILS == 3U)
if ( (u16FullStep == 1U) || (u16FullStep == 4U) )
{
ADC_SDATA_t u16PhV = C_ADC_VPHV_EOC;
l_au16AdcSource[5] = u16PhV.u16;
}
else if ( (u16FullStep == 2U) || (u16FullStep == 5U) )
{
ADC_SDATA_t u16PhW = C_ADC_VPHW_EOC;
l_au16AdcSource[5] = u16PhW.u16;
}
else
{
}
#elif (C_MOTOR_COILS == 2U) && (C_MOTOR_PHASES == 4U)
#if (_SUPPORT_PWM_MODE == BIPOLAR_FULL_STEP_BEMF)
if ( (u16FullStep == 0U) || (u16FullStep == 2U) )
#else
if ( (u16HalfStep == 0U) || (u16HalfStep == 4U) )
#endif
{
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_WT) || (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_TW)
ADC_SDATA_t u16PhT = C_ADC_VPHT_EOC;
ADC_SDATA_t u16PhW = C_ADC_VPHW_EOC;
l_au16AdcSource[4] = u16PhW.u16;
l_au16AdcSource[6] = u16PhT.u16;
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
ADC_SDATA_t u16PhT = C_ADC_VPHT_EOC;
ADC_SDATA_t u16PhV = C_ADC_VPHV_EOC;
l_au16AdcSource[4] = u16PhV.u16;
l_au16AdcSource[6] = u16PhT.u16;
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW)
ADC_SDATA_t u16PhV = C_ADC_VPHV_EOC;
ADC_SDATA_t u16PhW = C_ADC_VPHW_EOC;
l_au16AdcSource[4] = u16PhV.u16;
l_au16AdcSource[6] = u16PhW.u16;
#else
#error "ERROR: Bi-Polar Full-step not implemented"
#endif
}
#endif
#endif
}
HAL_ADC_Setup(
C_ADC_ASB_NEVER |
#if ((_SUPPORT_FOC_MODE != FOC_MODE_NONE) && (_SUPPORT_PWM_MODE != SINGLE_COIL_PWM_BIPOLAR)) || \
(_SUPPORT_PWM_MODE == TRIPLEPHASE_FULL_STEP_BEMF) || (_SUPPORT_PWM_MODE == BIPOLAR_FULL_STEP_BEMF) || (_SUPPORT_PWM_MODE == BIPOLAR_HALF_STEP_BEMF) || \
(_SUPPORT_PWM_MODE == SINGLE_COIL_PWM)
C_ADC_INT_SCHEME_EOF |
#elif (_DEBUG_IO_ADC != FALSE)
C_ADC_INT_SCHEME_EOC |
#else
C_ADC_INT_SCHEME_NOINT |
#endif
B_ADC_SATURATE |
B_ADC_NO_INTERLEAVE |
C_ADC_SOC_SOURCE_HARD_CTRIG |
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_HW)
C_ADC_SOS_SOURCE_2ND_HARD_CTRIG);
#else
C_ADC_SOS_SOURCE_SOFT_TRIG);
#endif
HAL_ADC_ClearErrors();
#if (_DEBUG_IO_ADC != FALSE) || \
((_SUPPORT_FOC_MODE != FOC_MODE_NONE) && (_SUPPORT_PWM_MODE != SINGLE_COIL_PWM_BIPOLAR)) || \
(_SUPPORT_PWM_MODE == TRIPLEPHASE_FULL_STEP_BEMF) || (_SUPPORT_PWM_MODE == BIPOLAR_FULL_STEP_BEMF) || (_SUPPORT_PWM_MODE == BIPOLAR_HALF_STEP_BEMF) || \
(_SUPPORT_PWM_MODE == SINGLE_COIL_PWM)
if (u16IrqEna != FALSE)
{
#if (_DEBUG_IO_ADC != FALSE)
HAL_ADC_SetPrioAndEnableIRQ(C_MLX16_ITC_PRIO2_ADC_PRIO6);
#else
HAL_ADC_SetPrioAndEnableIRQ(C_MLX16_ITC_PRIO2_ADC_PRIO4);
#endif
}
#else
(void)u16IrqEna;
#endif
HAL_ADC_Start();
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_SW)
DELAY_US(C_ADC_SETTLING_TIME);
if ( (IO_ADC_STATUS & M_ADC_STATE) == C_ADC_STATE_MEM_TRANSFER)
{
HAL_ADC_Stop();
}
DELAY_US(C_ADC_SETTLING_TIME);
HAL_ADC_SoftTrigger();
#endif
#if (_SUPPORT_STALLDET_BZC != FALSE)
l_u8AdcMode = (uint8_t)C_ADC_MODE_ON_STEPPER;
#else
l_u8AdcMode = (uint8_t)C_ADC_MODE_RUN_HW;
#endif
}
#if (_SUPPORT_STALLDET_BRI != FALSE)
else
{
#if (C_MOTOR_COILS == 3U)
if ( (u16FullStep == 0U) || (u16FullStep == 3U) )
{
ADC_SDATA_t u16PhU = C_ADC_VPHU_EOC;
l_au16AdcSource[5] = u16PhU.u16;
}
else if ( (u16FullStep == 1U) || (u16FullStep == 4U) )
{
ADC_SDATA_t u16PhV = C_ADC_VPHV_EOC;
l_au16AdcSource[5] = u16PhV.u16;
}
else
{
ADC_SDATA_t u16PhW = C_ADC_VPHW_EOC;
l_au16AdcSource[5] = u16PhW.u16;
}
#elif (C_MOTOR_COILS == 2U) && (C_MOTOR_PHASES == 4U)
#if (_SUPPORT_PWM_MODE == BIPOLAR_FULL_STEP_BEMF)
if ( (u16FullStep == 0U) || (u16FullStep == 2U) )
#else
if ( (u16HalfStep == 0U) || (u16HalfStep == 4U) )
#endif
{
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_WT) || (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_TW)
ADC_SDATA_t u16PhT = C_ADC_VPHT_EOC;
ADC_SDATA_t u16PhW = C_ADC_VPHW_EOC;
l_au16AdcSource[4] = u16PhW.u16;
l_au16AdcSource[6] = u16PhT.u16;
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
ADC_SDATA_t u16PhT = C_ADC_VPHT_EOC;
ADC_SDATA_t u16PhV = C_ADC_VPHV_EOC;
l_au16AdcSource[4] = u16PhV.u16;
l_au16AdcSource[6] = u16PhT.u16;
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW)
ADC_SDATA_t u16PhV = C_ADC_VPHV_EOC;
ADC_SDATA_t u16PhW = C_ADC_VPHW_EOC;
l_au16AdcSource[4] = u16PhV.u16;
l_au16AdcSource[6] = u16PhW.u16;
#endif
}
else
{
ADC_SDATA_t u16PhU = C_ADC_VPHU_EOC;
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_WT) || (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UV_TW)
ADC_SDATA_t u16PhV = C_ADC_VPHV_EOC;
l_au16AdcSource[6] = u16PhV.u16;
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
ADC_SDATA_t u16PhW = C_ADC_VPHW_EOC;
l_au16AdcSource[6] = u16PhW.u16;
#elif (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW)
ADC_SDATA_t u16PhT = C_ADC_VPHT_EOC;
l_au16AdcSource[6] = u16PhT.u16;
#endif
l_au16AdcSource[4] = u16PhU.u16;
}
#endif
}
if (l_u16MotorBemf_IntegrationCount != 0U)
{
g_u16MotorBemfVoltage = p_DivU16_U32byU16(l_u32MotorBemfVoltage_Integration, l_u16MotorBemf_IntegrationCount);
}
else
{
g_u16MotorBemfVoltage = 0U;
}
l_u32MotorBemfVoltage_Integration = 0U;
l_u16MotorBemf_IntegrationCount = 0U;
l_u16MotorBemf_IgnoreCount = ((PWM_FREQ + (800U / 2)) / 800U);
#endif
}
#if (_SUPPORT_MOTION_DET == C_MOTION_DET_BEMF) || (_SUPPORT_MOTION_DET == C_MOTION_DET_SENSOR)
void ADC_MovementDetection(void)
{
#if (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_INDEPENDENT_GND) || \
(_SUPPORT_PWM_MODE == BIPOLAR_TRIPHASE_TWOPWM_INDEPENDENT_GND)
static const ADC_SDATA_t SBASE_MOTION[] =
{
{.u16 = (uint16_t)&l_AdcResult.u16AdcVs},
C_ADC_VS_MSTR1_CMP,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
#if (_SUPPORT_ADC_BGD != FALSE)
C_ADC_VBGD_EOC,
C_ADC_VAUX_EOC,
#endif
C_ADC_VDDD_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_PH_U_HV,
.u3AdcVref = C_ADC_VREF_HV,
.u5AdcTrigger = C_ADC_HW_TRIGGER_SLV2_CMP,
.u1AdcReserved = 0U
}
},
C_ADC_VSMF_EOC,
C_ADC_TEMP_EOC,
C_ADC_VPHV_EOC,
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_PH_W_HV,
.u3AdcVref = C_ADC_VREF_HV,
#if (_SUPPORT_ADC_PWM_DELAY != FALSE)
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR2_CMP,
#else
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR1_CNT,
#endif
.u1AdcReserved = 0U
}
},
{.u16 = C_ADC_EOF},
{.u16 = (uint16_t)&l_au16AdcSource[0]}
};
#else
#error "ERROR: _SUPPORT_PWM_MODE not supported."
#endif
if (l_u8AdcMode != (uint8_t)C_ADC_MODE_MOV_DET)
{
HAL_ADC_StopSafe();
{
uint16_t *pu16Src = &l_au16AdcSource[0];
ADC_SDATA_t *pu16SBase = &SBASE_MOTION[0];
do
{
*pu16Src = pu16SBase->u16;
pu16Src++;
pu16SBase++;
} while (pu16SBase < (ADC_SDATA_t *)&SBASE_MOTION[sizeof(SBASE_MOTION) / sizeof(uint16_t)]);
}
HAL_ADC_Setup(
C_ADC_ASB_NEVER |
C_ADC_INT_SCHEME_EOF |
B_ADC_SATURATE |
B_ADC_NO_INTERLEAVE |
C_ADC_SOC_SOURCE_HARD_CTRIG |
#if (_SUPPORT_ADC_SOS_TRIGGER == ADC_SOS_TRIGGER_HW)
C_ADC_SOS_SOURCE_2ND_HARD_CTRIG);
#else
C_ADC_SOS_SOURCE_SOFT_TRIG);
#endif
HAL_ADC_ClearErrors();
HAL_ADC_EnableIRQ();
HAL_ADC_Start();
l_u8AdcMode = (uint8_t)C_ADC_MODE_MOV_DET;
}
}
#endif
#if (_SUPPORT_STALLDET_BZC != FALSE)
void ADC_BEMF_Start(uint16_t u16Idx)
{
static const ADC_SDATA_t SBASE_INIT_BEMF_U[] =
{
{.u16 = (uint16_t)&l_AdcMotorRunBemf.u16AdcVs},
C_ADC_VS_MSTR1_CMP,
C_ADC_VSMF_EOC,
#if (_SUPPORT_BEMF_STARPOINT != FALSE)
C_ADC_IO0_HV_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_PH_U_HV,
.u3AdcVref = C_ADC_VREF_HV,
.u5AdcTrigger = C_ADC_HW_TRIGGER_SLV2_CMP,
.u1AdcReserved = 0U
}
},
C_ADC_MCUR_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_PH_U_HV,
.u3AdcVref = C_ADC_VREF_HV,
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR1_CNT,
.u1AdcReserved = 0U
}
},
{.u16 = C_ADC_EOF},
{.u16 = (uint16_t)&l_au16AdcSource[0]}
};
static const ADC_SDATA_t SBASE_INIT_BEMF_V[] =
{
{.u16 = (uint16_t)&l_AdcMotorRunBemf.u16AdcVs},
C_ADC_VS_MSTR1_CMP,
C_ADC_VSMF_EOC,
#if (_SUPPORT_BEMF_STARPOINT != FALSE)
C_ADC_IO0_HV_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_PH_V_HV,
.u3AdcVref = C_ADC_VREF_HV,
.u5AdcTrigger = C_ADC_HW_TRIGGER_SLV2_CMP,
.u1AdcReserved = 0U
}
},
C_ADC_MCUR_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_PH_V_HV,
.u3AdcVref = C_ADC_VREF_HV,
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR1_CNT,
.u1AdcReserved = 0U
}
},
{.u16 = C_ADC_EOF},
{.u16 = (uint16_t)&l_au16AdcSource[0]}
};
static const ADC_SDATA_t SBASE_INIT_BEMF_W[] =
{
{.u16 = (uint16_t)&l_AdcMotorRunBemf.u16AdcVs},
C_ADC_VS_MSTR1_CMP,
C_ADC_VSMF_EOC,
#if (_SUPPORT_BEMF_STARPOINT != FALSE)
C_ADC_IO0_HV_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_PH_W_HV,
.u3AdcVref = C_ADC_VREF_HV,
.u5AdcTrigger = C_ADC_HW_TRIGGER_SLV2_CMP,
.u1AdcReserved = 0U
}
},
C_ADC_MCUR_EOC,
C_ADC_TEMP_EOC,
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
C_ADC_VDDA_EOC,
#endif
{
{
.u2AdcMarker = C_ADC_NO_SIGN,
.u5AdcChannel = C_ADC_PH_W_HV,
.u3AdcVref = C_ADC_VREF_HV,
.u5AdcTrigger = C_ADC_HW_TRIGGER_MSTR1_CNT,
.u1AdcReserved = 0U
}
},
{.u16 = C_ADC_EOF},
{.u16 = (uint16_t)&l_au16AdcSource[0]}
};
l_u16FullStepIndex = u16Idx;
if (l_u8AdcMode != (uint8_t)C_ADC_MODE_ON_BEMF)
{
HAL_ADC_StopSafe();
#if (_SUPPORT_PWM_MODE == TRIPLEPHASE_ALLPWM_MIRROR)
IO_PWM_SLAVE2_CMP = (((4UL * PWM_REG_PERIOD) + 4U) / 8U);
#endif
{
const ADC_SDATA_t *pu16SBase;
if ( (u16Idx == 0U) || (u16Idx == 3U) )
{
pu16SBase = &SBASE_INIT_BEMF_U[0];
}
else if ( (u16Idx == 1U) || (u16Idx == 4U) )
{
pu16SBase = &SBASE_INIT_BEMF_V[0];
}
else
{
pu16SBase = &SBASE_INIT_BEMF_W[0];
}
p_MemCpyU16(&l_au16AdcSource[0], (uint16_t *)pu16SBase,
(sizeof(SBASE_INIT_BEMF_U) / sizeof(uint16_t)));
}
#if (_SUPPORT_BEMF_STARPOINT != FALSE)
IO_PORT_IO_ENABLE = (IO_PORT_IO_ENABLE & ~B_PORT_IO_ENABLE_IO_ENABLE_0) |
B_PORT_IO_ENABLE_IO_DISREC_0;
IO_PORT_IO_OUT_EN = (IO_PORT_IO_OUT_EN & ~(B_PORT_IO_OUT_EN_IO_LV_ENABLE_0 |
B_PORT_IO_OUT_EN_IO_HS_ENABLE_0));
#endif
HAL_ADC_Setup(
C_ADC_ASB_NEVER |
C_ADC_INT_SCHEME_EOF |
B_ADC_SATURATE |
B_ADC_NO_INTERLEAVE |
C_ADC_SOC_SOURCE_HARD_CTRIG |
C_ADC_SOS_SOURCE_2ND_HARD_CTRIG);
HAL_ADC_ClearErrors();
HAL_ADC_EnableIRQ();
HAL_ADC_Start();
l_u8AdcMode = (uint8_t)C_ADC_MODE_ON_BEMF;
}
else
{
const ADC_SDATA_t *pu16SBase;
if ( (u16Idx == 0U) || (u16Idx == 3U) )
{
pu16SBase = &SBASE_INIT_BEMF_U[0];
}
else if ( (u16Idx == 1U) || (u16Idx == 4U) )
{
pu16SBase = &SBASE_INIT_BEMF_V[0];
}
else
{
pu16SBase = &SBASE_INIT_BEMF_W[0];
}
#if (_SUPPORT_BEMF_STARPOINT != FALSE)
u16Idx = 4U;
#else
u16Idx = 3U;
#endif
l_au16AdcSource[u16Idx] = pu16SBase[u16Idx].u16;
#if (_SUPPORT_ADC_VDDA_VDDD != FALSE)
u16Idx += 4U;
#else
u16Idx += 3U;
#endif
l_au16AdcSource[u16Idx] = pu16SBase[u16Idx].u16;
}
}
static uint16_t CalcCommutPeriod(uint16_t u16CommutToZeroCrossTime)
{
uint16_t u16Period;
uint16_t u16HalfCommutTimerPeriod = (l_u16ZcTime + u16CommutToZeroCrossTime) >> 1;
l_u16ZcTime = u16CommutToZeroCrossTime;
if (u16HalfCommutTimerPeriod < C_MIN_HCOMMUT_TIME)
{
u16HalfCommutTimerPeriod = C_MIN_HCOMMUT_TIME;
}
else if (u16HalfCommutTimerPeriod > C_MAX_HCOMMUT_TIME)
{
u16HalfCommutTimerPeriod = C_MAX_HCOMMUT_TIME;
}
u16Period = l_u16ZcTime + u16HalfCommutTimerPeriod;
#if (_SUPPORT_BEMF_LEADANGLE_COMPENSATE != FALSE)
u16Period -= p_MulU32_U16byU16(u16HalfCommutTimerPeriod, NV_LEADANGLE_COMPENSATION) >> 4;
#endif
return (u16Period);
}
#endif
#if ((_SUPPORT_FOC_MODE == FOC_MODE_NONE) || (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM_BIPOLAR)) && \
(_SUPPORT_PWM_MODE != SINGLE_COIL_PWM)
__attribute__((interrupt)) void ADC_ISR(void)
{
#if (_DEBUG_IO_ADC != FALSE)
DEBUG_TOG_IO_E();
#endif
#if (_SUPPORT_STALLDET_BRI != FALSE)
if (l_u16MotorBemf_IgnoreCount == 0U)
{
#if (_DEBUG_BEMF_SENSE != FALSE)
DEBUG_SET_IO_D();
#endif
uint16_t u16BemfVoltage = p_Abs16(GetRawMotorBemfVoltage());
l_u32MotorBemfVoltage_Integration += u16BemfVoltage;
l_u16MotorBemf_IntegrationCount++;
#if (_DEBUG_MOTOR_CURRENT_FLT != FALSE) && (_DEBUG_BEMF_SENSE != FALSE)
{
uint8_t *pBfr = &g_au8DebugBuf[g_u16DebugBufWrIdx];
pBfr[0] = (uint8_t)(u16BemfVoltage >> 2);
g_u16DebugBufWrIdx += 1U;
if (g_u16DebugBufWrIdx >= C_DEBUG_BUF_SZ)
{
g_u16DebugBufWrIdx = 0U;
}
}
#endif
#if (_DEBUG_BEMF_SENSE != FALSE)
DEBUG_CLR_IO_D();
#endif
}
else
{
l_u16MotorBemf_IgnoreCount--;
}
#endif
#if (_SUPPORT_STALLDET_BZC != FALSE)
#if (_DEBUG_COMMUT_ISR != FALSE)
DEBUG_SET_IO_C();
#endif
if (l_u8AdcMode == (uint8_t)C_ADC_MODE_ON_BEMF)
{
uint16_t u16CommutToZeroCrossTime = IO_CTIMER0_TCNT;
if (g_e8ZcDetectorState == (uint8_t)ZC_RESET)
{
g_e8ZcDetectorState = (uint8_t)ZC_INIT;
}
else if ( (g_e8ZcDetectorState & (uint8_t)ZC_FOUND) == 0U)
{
uint16_t u16VsmVoltage = l_AdcMotorRunBemf.u16AdcVsmF;
#if (_SUPPORT_BEMF_STARPOINT != FALSE)
uint16_t u16StarPointVoltage = l_AdcMotorRunBemf.u16AdcVio0HV;
#endif
uint16_t u16BemfVoltage = ((l_AdcMotorRunBemf.u16AdcVphA +
l_AdcMotorRunBemf.u16AdcVphB) >> 1);
#if (_SUPPORT_BEMF_STARPOINT != FALSE)
if (l_u16ZeroCrossVoltage != 0U)
{
l_u16ZeroCrossVoltage = ((l_u16ZeroCrossVoltage + u16StarPointVoltage) >> 1);
}
else
{
l_u16ZeroCrossVoltage = u16StarPointVoltage;
}
#else
if (l_u16ZeroCrossVoltage != 0U)
{
l_u16ZeroCrossVoltage = ((l_u16ZeroCrossVoltage + (u16VsmVoltage >> 1)) >> 1);
}
else
{
l_u16ZeroCrossVoltage = (u16VsmVoltage >> 1);
}
#endif
if ( ((l_u16FullStepIndex ^ g_e8MotorDirectionCCW) & 1U) == 0U)
{
if (u16BemfVoltage < (u16VsmVoltage - C_1VOLT) )
{
if ( (g_e8ZcDetectorState & (uint8_t)ZC_START) == 0U)
{
if (u16BemfVoltage < l_u16ZeroCrossVoltage)
{
g_e8ZcDetectorState = (uint8_t)ZC_START;
}
else
{
g_e8ZcDetectorState = (uint8_t)(ZC_START | ZC_ERROR);
}
}
else
{
if (u16BemfVoltage > (l_u16ZeroCrossVoltage + C_100MV) )
{
#if (_DEBUG_COMMUT_ISR != FALSE)
DEBUG_SET_IO_B();
#endif
IO_CTIMER0_TREGB = CalcCommutPeriod(u16CommutToZeroCrossTime);
g_e8ZcDetectorState = (uint8_t)ZC_FOUND;
#if (_DEBUG_COMMUT_ISR != FALSE)
DEBUG_CLR_IO_B();
#endif
}
}
}
else
{
}
}
else
{
if (u16BemfVoltage > C_1VOLT)
{
if ( (g_e8ZcDetectorState & (uint8_t)ZC_START) == 0U)
{
if (u16BemfVoltage > l_u16ZeroCrossVoltage)
{
g_e8ZcDetectorState = (uint8_t)ZC_START;
}
else
{
g_e8ZcDetectorState = (uint8_t)(ZC_START | ZC_ERROR);
}
}
else
{
if (u16BemfVoltage < (l_u16ZeroCrossVoltage - C_100MV) )
{
#if (_DEBUG_COMMUT_ISR != FALSE)
DEBUG_SET_IO_B();
#endif
IO_CTIMER0_TREGB = CalcCommutPeriod(u16CommutToZeroCrossTime);
g_e8ZcDetectorState = (uint8_t)ZC_FOUND;
#if (_DEBUG_COMMUT_ISR != FALSE)
DEBUG_CLR_IO_B();
#endif
}
}
}
else
{
}
}
#if (_DEBUG_MOTOR_CURRENT_FLT != FALSE) && (_DEBUG_MOTOR_BEMF != FALSE)
extern uint8_t g_au8DebugBuf[C_DEBUG_BUF_SZ];
extern uint16_t g_u16DebugBufWrIdx;
#if (_DEBUG_MCUR_CYCLIC == FALSE)
if (g_u16DebugBufWrIdx < C_DEBUG_BUF_SZ)
#endif
{
uint8_t *pu8Ptr = &g_au8DebugBuf[g_u16DebugBufWrIdx];
*pu8Ptr++ = (uint8_t)((u16BemfVoltage >> 1U) & 0xFFU);
*pu8Ptr++ = (uint8_t)((l_u16ZeroCrossVoltage >> 1U) & 0xFFU);
g_u16DebugBufWrIdx += 2U;
#if (_DEBUG_MCUR_CYCLIC != FALSE)
if (g_u16DebugBufWrIdx >= C_DEBUG_BUF_SZ)
{
g_u16DebugBufWrIdx = 0U;
}
#endif
}
#endif
}
}
#if (_DEBUG_COMMUT_ISR != FALSE)
DEBUG_CLR_IO_C();
#endif
#endif
#if (_SUPPORT_MOTION_DET != C_MOTION_DET_NONE)
if (l_u8AdcMode == (uint8_t)C_ADC_MODE_MOV_DET)
{
#if (_SUPPORT_MOTION_DET == C_MOTION_DET_BEMF)
MotionDetectorBEMF();
#elif (_SUPPORT_MOTION_DET == C_MOTION_DET_SENSOR)
MotionDetectorSensor();
#endif
return;
}
#endif
}
#endif
#if ((_SUPPORT_FOC_MODE != FOC_MODE_NONE) && (_SUPPORT_PWM_MODE != SINGLE_COIL_PWM_BIPOLAR)) && \
(_SUPPORT_RAM_FUNC != FALSE)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx) __attribute__ ((section(".ramfunc"))) __attribute__ ((aligned(8)));
#elif ((_SUPPORT_FOC_MODE != FOC_MODE_NONE) && (_SUPPORT_PWM_MODE != SINGLE_COIL_PWM_BIPOLAR)) && \
(_SUPPORT_OPTIMIZE_FOR_SPEED != FALSE)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx) __attribute__((aligned(8)));
#endif
#if (_SUPPORT_PWM_MODE != SINGLE_COIL_PWM_BIPOLAR) && (_SUPPORT_PWM_MODE != SINGLE_COIL_PWM) && \
(_SUPPORT_APP_TYPE != C_APP_SOLENOID) && (_SUPPORT_PWM_MODE != BIPOLAR_FULL_STEP_BEMF) && (_SUPPORT_PWM_MODE != BIPOLAR_HALF_STEP_BEMF) && \
((_SUPPORT_FOC_MODE != FOC_MODE_NONE) || (_SUPPORT_STALLDET_LA != FALSE) || \
((_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDENT_GND) && (_SUPPORT_PWM_MODE != BIPOLAR_FULL_STEP_BEMF) && (_SUPPORT_PWM_MODE != BIPOLAR_HALF_STEP_BEMF)))
static inline void CalcMotorCurrentAngleAndPeak(void)
{
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE) || (_SUPPORT_STALLDET_LA != FALSE)
#if (_SUPPORT_FAST_ATAN2 != FALSE)
g_i16MotorCurrentAngle = (int16_t)p_atan2I16(g_i16MotorCurrentCoilA, g_i16MotorCurrentCoilY);
#else
g_i16MotorCurrentAngle = (int16_t)atan2I16(g_i16MotorCurrentCoilA, g_i16MotorCurrentCoilY);
#endif
#if (_SUPPORT_BEMF_SINUSOIDAL == FALSE)
g_u16MotorCurrentPeak = p_AproxSqrtU16_I16byI16(g_i16MotorCurrentCoilA, g_i16MotorCurrentCoilY);
#else
#if (_SUPPORT_SINCOS_TABLE_SZ == 256)
uint16_t u16Idx = ((uint16_t)g_i16MotorCurrentAngle / 256);
int16_t *pi16SinCos = (int16_t *) &c_ai16MicroStepVector3PH_SinCos256[u16Idx];
#elif (_SUPPORT_SINCOS_TABLE_SZ == 192)
uint16_t u16Idx = (uint16_t)p_MulU16hi_U16byU16((uint16_t)g_i16MotorCurrentAngle, l_u16MotorMicroStepsPerElecRotation);
int16_t *pi16SinCos = (int16_t *) &c_ai16MicroStepVector3PH_SinCos192[u16Idx];
#elif (_SUPPORT_SINCOS_TABLE_SZ == 1024)
int16_t *pi16SinCos = p_SinDirectLutInlined_2_5k(g_i16MotorCurrentAngle);
#endif
g_u16MotorCurrentPeak = p_MulI16_I16bypQ15( g_i16MotorCurrentCoilA, pi16SinCos) +
p_MulI16_I16bypQ15( g_i16MotorCurrentCoilY, (pi16SinCos + C_COS_OFFSET));
#endif
#else
g_u16MotorCurrentPeak = p_AproxSqrtU16_I16byI16(g_i16MotorCurrentCoilA, g_i16MotorCurrentCoilY);
#endif
}
#endif
#if (_SUPPORT_APP_TYPE == C_APP_SOLENOID)
uint16_t ADC_GetRawMotorDriverCurrent(void)
{
uint16_t u16Current = l_AdcResult.u16AdcCurr;
if (u16Current > l_u16CurrentZeroOffset)
{
g_u16MotorCurrentPeak = u16Current - Get_CurrentZeroOffset();
}
else
{
g_u16MotorCurrentPeak = 0U;
}
return (g_u16MotorCurrentPeak);
}
#else
#if (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
uint16_t u16Current = ((l_AdcResult.u16AdcCurrA_1 + l_AdcResult.u16AdcCurrB_1) +
(l_AdcResult.u16AdcCurrA_2 + l_AdcResult.u16AdcCurrB_2));
uint16_t u16ZeroOffset = (4U * Get_CurrentZeroOffset());
if (u16Current > u16ZeroOffset)
{
u16Current = u16Current - u16ZeroOffset;
}
else
{
u16Current = 0U;
}
g_u16MotorCurrentPeak = u16Current;
(void)u16MicroStepIdx;
return (u16Current);
}
#elif (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM_BIPOLAR)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
uint16_t u16Current = l_AdcResult.u16AdcCurr;
(void)u16MicroStepIdx;
if (u16Current > Get_CurrentZeroOffset() )
{
u16Current -= Get_CurrentZeroOffset();
}
else
{
u16Current = 0U;
}
return (u16Current);
}
#elif (_SUPPORT_PWM_MODE == BIPOLAR_FULL_STEP_BEMF) || (_SUPPORT_PWM_MODE == BIPOLAR_HALF_STEP_BEMF)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
(void)u16MicroStepIdx;
g_i16MotorCurrentCoilA = (int16_t)(l_AdcResult.u16AdcCurrA - Get_CurrentZeroOffset());
g_u16MotorCurrentPeak = g_i16MotorCurrentCoilA;
return (g_u16MotorCurrentPeak);
}
#elif (_SUPPORT_PWM_MODE == BIPOLAR_TRIPHASE_TWOPWM_INDEPENDENT_GND)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
register uint16_t u16Offset = Get_CurrentZeroOffset();
if (u16MicroStepIdx >= ((9U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
}
else
{
g_i16MotorCurrentCoilB = ((2U * u16Offset) - (l_AdcResult.u16AdcCurrB + l_AdcResult.u16AdcCurrA));
}
if (u16MicroStepIdx <= ((15U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrA - u16Offset);
}
else
{
g_i16MotorCurrentCoilA = ((2U * u16Offset) - (l_AdcResult.u16AdcCurrB + l_AdcResult.u16AdcCurrA));
}
CalcMotorCurrentAngleAndPeak();
return (g_u16MotorCurrentPeak);
}
#elif (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDENT_GND)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
#if (_SUPPORT_STALLDET_BZC != FALSE)
u16Current = 0U;
#endif
#if (_SUPPORT_FOC_MODE == FOC_MODE_NONE)
(void)u16MicroStepIdx;
#endif
g_i16MotorCurrentCoilA = (int16_t)(l_AdcResult.u16AdcCurrA - Get_CurrentZeroOffset());
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE) || (_SUPPORT_STALLDET_LA != FALSE)
if (u16MicroStepIdx >= (2U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilA = -g_i16MotorCurrentCoilA;
}
#endif
#if (_SUPPORT_STALLDET_BZC != FALSE)
if (g_i16MotorCurrentCoilA > 0)
{
u16Current = (uint16_t)g_i16MotorCurrentCoilA;
}
#endif
g_i16MotorCurrentCoilB = (int16_t)(l_AdcResult.u16AdcCurrB - Get_CurrentZeroOffset());
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE) || (_SUPPORT_STALLDET_LA != FALSE)
if ( (u16MicroStepIdx >= C_MICROSTEP_PER_FULLSTEP) && (u16MicroStepIdx < (3U * C_MICROSTEP_PER_FULLSTEP)) )
{
g_i16MotorCurrentCoilB = -g_i16MotorCurrentCoilB;
}
#endif
#if (_SUPPORT_STALLDET_BZC != FALSE)
if (g_i16MotorCurrentCoilB > 0)
{
u16Current += (uint16_t)g_i16MotorCurrentCoilB;
}
g_u16MotorCurrentPeak = u16Current;
return (g_u16MotorCurrentPeak);
#else
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE) || (_SUPPORT_STALLDET_LA != FALSE)
CalcMotorCurrentAngleAndPeak();
#else
g_u16MotorCurrentPeak = p_AproxSqrtU16_I16byI16(g_i16MotorCurrentCoilA, g_i16MotorCurrentCoilB);
#endif
return (g_u16MotorCurrentPeak);
#endif
}
#elif (_SUPPORT_PWM_MODE == BIPOLAR_TRIPHASE_ALLPWM_MIRROR)
#if (_SUPPORT_FOC_MODE != FOC_MODE_NONE)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
register uint16_t u16Offset = Get_CurrentZeroOffset();
if (u16MicroStepIdx < ((3U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (0 - (g_i16MotorCurrentCoilB + g_i16MotorCurrentCoilC));
}
else if (u16MicroStepIdx < ((9U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilC));
}
else if (u16MicroStepIdx < ((12U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilB));
}
else if (u16MicroStepIdx < ((15U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (0 - (g_i16MotorCurrentCoilB + g_i16MotorCurrentCoilC));
}
else if (u16MicroStepIdx < ((21U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilC));
}
else
{
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilB));
}
g_u16MotorCurrentPeak = p_AproxSqrtU16_I16byI16(g_i16MotorCurrentCoilA, g_i16MotorCurrentCoilC);
return (g_u16MotorCurrentPeak);
}
#else
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
register uint16_t u16Offset = Get_CurrentZeroOffset();
if (u16MicroStepIdx < ((3U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (0 - (g_i16MotorCurrentCoilB + g_i16MotorCurrentCoilC));
}
else if (u16MicroStepIdx < ((9U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilC));
}
else if (u16MicroStepIdx < ((12U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilB));
}
else if (u16MicroStepIdx < ((15U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (0 - (g_i16MotorCurrentCoilB + g_i16MotorCurrentCoilC));
}
else if (u16MicroStepIdx < ((21U * C_MICROSTEP_PER_FULLSTEP) / 4U) )
{
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilC));
}
else
{
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilB));
}
g_u16MotorCurrentPeak = p_AproxSqrtU16_I16byI16(g_i16MotorCurrentCoilA, g_i16MotorCurrentCoilC);
return (g_u16MotorCurrentPeak);
}
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_ALLPWM_MIRROR)
#if (_SUPPORT_STALLDET_BZC != FALSE)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
uint16_t u16Current = 0U;
if (l_u8AdcMode == (uint8_t)C_ADC_MODE_ON_BEMF)
{
u16Current = l_AdcMotorRunBemf.u16AdcCurr;
}
else
{
u16Current = l_AdcResult.u16AdcCurr;
}
if (u16Current > Get_CurrentZeroOffset() )
{
u16Current = u16Current - Get_CurrentZeroOffset();
}
else
{
u16Current = 0U;
}
g_u16MotorCurrentPeak = u16Current;
(void)u16MicroStepIdx;
return (u16Current);
}
#elif (_SUPPORT_FOC_MODE != FOC_MODE_NONE)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
register uint16_t u16Offset = Get_CurrentZeroOffset();
uint16_t u16PhaseIdx = (u16MicroStepIdx + (C_MICROSTEP_PER_FULLSTEP / 2U)) &
~(C_MICROSTEP_PER_FULLSTEP - 1U);
if (u16PhaseIdx == (1U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilC));
}
else if (u16PhaseIdx == (2U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilB));
}
else if (u16PhaseIdx == (3U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (0 - (g_i16MotorCurrentCoilB + g_i16MotorCurrentCoilC));
}
else if (u16PhaseIdx == (4U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilC));
}
else if (u16PhaseIdx == (5U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilB));
}
else
{
g_i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (0 - (g_i16MotorCurrentCoilB + g_i16MotorCurrentCoilC));
}
g_i16MotorCurrentCoilY = p_MulI16_I16byQ15( (g_i16MotorCurrentCoilB - g_i16MotorCurrentCoilC), C_INV_SQRT3);
CalcMotorCurrentAngleAndPeak();
return (g_u16MotorCurrentPeak);
}
#else
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
register uint16_t u16Offset = Get_CurrentZeroOffset();
uint16_t u16PhaseIdx = (u16MicroStepIdx + (C_MICROSTEP_PER_FULLSTEP / 2U)) &
~(C_MICROSTEP_PER_FULLSTEP - 1U);
if (u16PhaseIdx == (1U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilC));
}
else if (u16PhaseIdx == (2U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilB));
}
else if (u16PhaseIdx == (3U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (0 - (g_i16MotorCurrentCoilB + g_i16MotorCurrentCoilC));
}
else if (u16PhaseIdx == (4U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilC));
}
else if (u16PhaseIdx == (5U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + g_i16MotorCurrentCoilB));
}
else
{
g_i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (0 - (g_i16MotorCurrentCoilB + g_i16MotorCurrentCoilC));
}
g_i16MotorCurrentCoilY = p_MulI16_I16byQ15( (g_i16MotorCurrentCoilB - g_i16MotorCurrentCoilC), C_INV_SQRT3);
CalcMotorCurrentAngleAndPeak();
return (g_u16MotorCurrentPeak);
}
#endif
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_MIRROR_SUP)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
uint16_t u16Current = 0U;
if (l_u8AdcMode == (uint8_t)C_ADC_MODE_ON_BEMF)
{
u16Current = l_AdcMotorRunBemf.u16AdcCurr;
}
else
{
u16Current = l_AdcResult.u16AdcCurr;
}
if (u16Current > Get_CurrentZeroOffset() )
{
u16Current = u16Current - Get_CurrentZeroOffset();
}
else
{
u16Current = 0U;
}
g_u16MotorCurrentPeak = u16Current;
(void)u16MicroStepIdx;
return (u16Current);
}
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_MIRROR_GND)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
uint16_t u16Current = 0U;
if (l_u8AdcMode == (uint8_t)C_ADC_MODE_ON_BEMF)
{
u16Current = l_AdcMotorRunBemf.u16AdcCurr;
}
else
{
u16Current = l_AdcResult.u16AdcCurr;
}
if (u16Current > Get_CurrentZeroOffset() )
{
u16Current = u16Current - Get_CurrentZeroOffset();
}
else
{
u16Current = 0U;
}
g_u16MotorCurrentPeak = u16Current;
(void)u16MicroStepIdx;
return (u16Current);
}
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_INDEPENDENT_GND)
#if (_SUPPORT_VARIABLE_PWM != FALSE)
void GetRawMotorCurrent_3PWM(void)
{
register uint16_t u16Offset = Get_CurrentZeroOffset();
g_i16MotorCurrentCoilA = (int16_t)(l_AdcResult3.u16AdcCurrA - u16Offset);
g_i16MotorCurrentCoilB = (int16_t)(l_AdcResult3.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilC = (int16_t)(l_AdcResult3.u16AdcCurrC - u16Offset);
g_i16MotorCurrentCoilY = p_MulI16_I16byQ15( (g_i16MotorCurrentCoilB - g_i16MotorCurrentCoilC), C_INV_SQRT3);
CalcMotorCurrentAngleAndPeak();
}
#endif
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
#if (_SUPPORT_VARIABLE_PWM != FALSE)
if (g_u8TriplePWM == FALSE)
#endif
{
register uint16_t u16Offset = Get_CurrentZeroOffset();
#if (_SUPPORT_VOLTAGE_SHAPE != VOLTAGE_SHAPE_DSVM_ALT)
int16_t i16CurrAB = (int16_t)(l_AdcResult.u16AdcCurrA - u16Offset);
int16_t i16CurrBC = (int16_t)(l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilB = i16CurrBC;
g_i16MotorCurrentCoilC = i16CurrBC;
i16CurrBC = (0 - (i16CurrAB + i16CurrBC));
{
uint16_t u16PhaseIdx = (u16MicroStepIdx + (C_MICROSTEP_PER_FULLSTEP / 2U)) &
~((2U * C_MICROSTEP_PER_FULLSTEP) - 1U);
if (u16PhaseIdx == (4U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilA = i16CurrBC;
g_i16MotorCurrentCoilB = i16CurrAB;
}
else
{
g_i16MotorCurrentCoilA = i16CurrAB;
if (u16PhaseIdx == (2U * C_MICROSTEP_PER_FULLSTEP) )
{
g_i16MotorCurrentCoilB = i16CurrBC;
}
else
{
g_i16MotorCurrentCoilC = i16CurrBC;
}
}
}
g_i16MotorCurrentCoilY = p_MulI16_I16byQ15( (g_i16MotorCurrentCoilB - g_i16MotorCurrentCoilC), C_INV_SQRT3);
CalcMotorCurrentAngleAndPeak();
#if (_APP_BURN_IN != FALSE)
g_u16MotorCurrentPeak =
p_MulDivU16_U16byU16byU16(g_u16MotorCurrentPeak, l_u16CorrectionRatio, (PWM_REG_PERIOD << 4));
#endif
#else
#if (_SUPPORT_OPTIMIZE_FOR_SPEED != FALSE)
int16_t i16MotorCurrentCoilB, i16MotorCurrentCoilC;
switch (u16MicroStepIdx / C_MICROSTEP_PER_FULLSTEP)
{
default:
__asm__ (
"lod A, X \n\t"
"sub A, %w3 \n\t"
"mov dp:_g_i16MotorCurrentCoilA, A \n\t"
"sub X, %w4 \n\t"
"add A, X \n\t"
"neg A \n\t"
: "=a" (i16MotorCurrentCoilB), "=x" (i16MotorCurrentCoilC)
: "x" (u16Offset), "" (l_AdcResult.u16AdcCurrA), "" (l_AdcResult.u16AdcCurrB)
);
break;
case 0U:
__asm__ (
"lod A, %w3 \n\t"
"sub A, X \n\t"
"neg X \n\t"
"add X, %w4 \n\t"
"mov dp:_g_i16MotorCurrentCoilA, X \n\t"
"add X, A \n\t"
"neg X \n\t"
: "=a" (i16MotorCurrentCoilB), "=x" (i16MotorCurrentCoilC)
: "x" (u16Offset), "" (l_AdcResult.u16AdcCurrA), "" (l_AdcResult.u16AdcCurrB)
);
break;
case 1U:
__asm__ (
"lod A, X \n\t"
"sub A, %w4 \n\t"
"sub X, %w3 \n\t"
"mov Y, A \n\t"
"add Y, X \n\t"
"neg Y \n\t"
"mov dp:_g_i16MotorCurrentCoilA, Y \n\t"
: "=a" (i16MotorCurrentCoilB), "=x" (i16MotorCurrentCoilC)
: "x" (u16Offset), "" (l_AdcResult.u16AdcCurrA), "" (l_AdcResult.u16AdcCurrB)
: "Y"
);
break;
case 2U:
__asm__ (
"lod A, %w3 \n\t"
"sub A, X \n\t"
"mov dp:_g_i16MotorCurrentCoilA, A \n\t"
"neg X \n\t"
"add X, %w4 \n\t"
"add A, X \n\t"
"neg A \n\t"
: "=a" (i16MotorCurrentCoilB), "=x" (i16MotorCurrentCoilC)
: "x" (u16Offset), "" (l_AdcResult.u16AdcCurrA), "" (l_AdcResult.u16AdcCurrB)
);
break;
case 3U:
__asm__ (
"lod A, X \n\t"
"sub A, %w3 \n\t"
"sub X, %w4 \n\t"
"mov dp:_g_i16MotorCurrentCoilA, X \n\t"
"add X, A \n\t"
"neg X \n\t"
: "=a" (i16MotorCurrentCoilB), "=x" (i16MotorCurrentCoilC)
: "x" (u16Offset), "" (l_AdcResult.u16AdcCurrA), "" (l_AdcResult.u16AdcCurrB)
);
break;
case 4U:
__asm__ (
"lod A, %w4 \n\t"
"sub A, X \n\t"
"neg X \n\t"
"add X, %w3 \n\t"
"mov Y, A \n\t"
"add Y, X \n\t"
"neg Y \n\t"
"mov dp:_g_i16MotorCurrentCoilA, Y \n\t"
: "=a" (i16MotorCurrentCoilB), "=x" (i16MotorCurrentCoilC)
: "x" (u16Offset), "" (l_AdcResult.u16AdcCurrA), "" (l_AdcResult.u16AdcCurrB)
: "Y"
);
break;
}
g_i16MotorCurrentCoilB = i16MotorCurrentCoilB;
g_i16MotorCurrentCoilC = i16MotorCurrentCoilC;
g_i16MotorCurrentCoilY = p_MulI16_I16byQ15( (i16MotorCurrentCoilB - i16MotorCurrentCoilC), C_INV_SQRT3);
#elif TRUE
int16_t i16MotorCurrentCoilB, i16MotorCurrentCoilC;
switch (u16MicroStepIdx / C_MICROSTEP_PER_FULLSTEP)
{
default:
i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrB);
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + i16MotorCurrentCoilC));
break;
case 0U:
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrA - u16Offset);
i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + i16MotorCurrentCoilB));
break;
case 1U:
i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrB);
i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (0 - (i16MotorCurrentCoilB + i16MotorCurrentCoilC));
break;
case 2U:
i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrA - u16Offset);
i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + i16MotorCurrentCoilC));
break;
case 3U:
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrB);
i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + i16MotorCurrentCoilB));
break;
case 4U:
i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrA - u16Offset);
g_i16MotorCurrentCoilA = (0 - (i16MotorCurrentCoilB + i16MotorCurrentCoilC));
break;
}
g_i16MotorCurrentCoilB = i16MotorCurrentCoilB;
g_i16MotorCurrentCoilC = i16MotorCurrentCoilC;
g_i16MotorCurrentCoilY = p_MulI16_I16byQ15( (i16MotorCurrentCoilB - i16MotorCurrentCoilC), C_INV_SQRT3);
#else
int16_t i16MotorCurrentCoilB, i16MotorCurrentCoilC;
uint16_t u16PhaseIdx = (u16MicroStepIdx / C_MICROSTEP_PER_FULLSTEP);
if (u16PhaseIdx == 0)
{
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrB - u16Offset);
i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrA - u16Offset);
i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + i16MotorCurrentCoilB));
}
else if (u16PhaseIdx == 1)
{
i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrB);
i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrA);
g_i16MotorCurrentCoilA = (0 - (i16MotorCurrentCoilB + i16MotorCurrentCoilC));
}
else if (u16PhaseIdx == 2)
{
i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrA - u16Offset);
i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + i16MotorCurrentCoilC));
}
else if (u16PhaseIdx == 3)
{
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrB);
i16MotorCurrentCoilB = (u16Offset - l_AdcResult.u16AdcCurrA);
i16MotorCurrentCoilC = (0 - (g_i16MotorCurrentCoilA + i16MotorCurrentCoilB));
}
else if (u16PhaseIdx == 4)
{
i16MotorCurrentCoilC = (l_AdcResult.u16AdcCurrA - u16Offset);
i16MotorCurrentCoilB = (l_AdcResult.u16AdcCurrB - u16Offset);
g_i16MotorCurrentCoilA = (0 - (i16MotorCurrentCoilB + i16MotorCurrentCoilC));
}
else
{
i16MotorCurrentCoilC = (u16Offset - l_AdcResult.u16AdcCurrB);
g_i16MotorCurrentCoilA = (u16Offset - l_AdcResult.u16AdcCurrA);
i16MotorCurrentCoilB = (0 - (g_i16MotorCurrentCoilA + i16MotorCurrentCoilC));
}
g_i16MotorCurrentCoilB = i16MotorCurrentCoilB;
g_i16MotorCurrentCoilC = i16MotorCurrentCoilC;
g_i16MotorCurrentCoilY = p_MulI16_I16byQ15( (i16MotorCurrentCoilB - i16MotorCurrentCoilC), C_INV_SQRT3);
#endif
CalcMotorCurrentAngleAndPeak();
#endif
}
#if (_SUPPORT_VARIABLE_PWM != FALSE)
else
{
GetRawMotorCurrent_3PWM();
}
#endif
return (g_u16MotorCurrentPeak);
}
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_FULL_STEP_BEMF)
uint16_t ADC_GetRawMotorDriverCurrent(uint16_t u16MicroStepIdx)
{
#if (_SUPPORT_STALLDET_BZC != FALSE)
if (l_u8AdcMode == (uint8_t)C_ADC_MODE_ON_BEMF)
{
g_i16MotorCurrentCoilA = (l_AdcMotorRunBemf.u16AdcCurr - Get_CurrentZeroOffset());
}
else
#endif
{
g_i16MotorCurrentCoilA = (l_AdcResult.u16AdcCurrA - Get_CurrentZeroOffset());
}
if (g_i16MotorCurrentCoilA > 0)
{
g_u16MotorCurrentPeak = (uint16_t)g_i16MotorCurrentCoilA;
}
else
{
g_u16MotorCurrentPeak = 0U;
}
(void)u16MicroStepIdx;
return (g_u16MotorCurrentPeak);
}
#endif
#endif
#if (_SUPPORT_STALLDET_BRI != FALSE)
int16_t GetRawMotorBemfVoltage(void)
{
#if (C_MOTOR_COILS == 3U)
uint16_t u16MotorSupplyVoltage = Get_RawVmotorF();
int16_t i16MotorBemfVoltage = (int16_t)l_AdcResult.u16AdcVbemf;
#if (_DEBUG_MOTOR_CURRENT_FLT != FALSE) && (_DEBUG_BEMF_SENSE != FALSE)
{
uint8_t *pBfr = &g_au8DebugBuf[g_u16DebugBufWrIdx];
pBfr[0] = (uint8_t)(u16MotorSupplyVoltage >> 2);
pBfr[1] = (uint8_t)(i16MotorBemfVoltage >> 2);
g_u16DebugBufWrIdx += 2U;
if (g_u16DebugBufWrIdx >= C_DEBUG_BUF_SZ)
{
g_u16DebugBufWrIdx = 0U;
}
}
#endif
i16MotorBemfVoltage = (i16MotorBemfVoltage - (u16MotorSupplyVoltage / 2U));
#elif (C_MOTOR_COILS == 2U) && (C_MOTOR_PHASES == 4U)
int16_t i16MotorBemfVoltage = (int16_t)(l_AdcResult.u16AdcVbemfA - l_AdcResult.u16AdcVbemfB);
#endif
return (i16MotorBemfVoltage);
}
#endif
void ADC_MeasureVsupplyAndTemperature(void)
{
HAL_ADC_StopSafe();
{
uint16_t *pu16Src = &l_au16AdcSource[0];
uint16_t *pu16SBase = (uint16_t *)&SBASE_MOTOR_IDLE[0];
*pu16Src++ = (uint16_t)&l_AdcResult;
pu16Src = p_MemCpyU16(pu16Src, (uint16_t *)pu16SBase,
(sizeof(SBASE_MOTOR_IDLE) / sizeof(uint16_t)));
*pu16Src = C_ADC_EOS;
}
(void)HAL_ADC_StartSoftTrig(C_ADC_STATE_IDLE);
if ( (IO_PORT_DRV_OUT & B_PORT_DRV_OUT_ENABLE_CSA) == 0U)
{
#if (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM) && (_SUPPORT_APP_TYPE != C_APP_SOLENOID)
l_AdcResult.u16AdcCurrA_1 = Get_CurrentZeroOffset();
#elif (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM_BIPOLAR) || (_SUPPORT_PWM_MODE == TRIPLEPHASE_TWOPWM_MIRROR_GND)
l_AdcResult.u16AdcCurr = Get_CurrentZeroOffset();
#elif (_SUPPORT_APP_TYPE == C_APP_SOLENOID)
l_AdcResult.u16AdcCurr = Get_CurrentZeroOffset();
#elif (_SUPPORT_PWM_MODE == TRIPLEPHASE_ALLPWM_MIRROR) && (_SUPPORT_STALLDET_BZC != FALSE)
l_AdcResult.u16AdcCurr = Get_CurrentZeroOffset();
#else
l_AdcResult.u16AdcCurrA = Get_CurrentZeroOffset();
#endif
}
#if (_SUPPORT_APP_TYPE != C_APP_SOLENOID) && (_SUPPORT_PWM_MODE != SINGLE_COIL_PWM_BIPOLAR) && \
(_SUPPORT_PWM_MODE != SINGLE_COIL_PWM) && (_SUPPORT_PWM_MODE != TRIPLEPHASE_TWOPWM_MIRROR_GND) && \
(_SUPPORT_PWM_MODE != TRIPLEPHASE_FULL_STEP_BEMF) && (_SUPPORT_PWM_MODE != BIPOLAR_FULL_STEP_BEMF) && (_SUPPORT_PWM_MODE != BIPOLAR_HALF_STEP_BEMF) && \
((_SUPPORT_PWM_MODE != TRIPLEPHASE_ALLPWM_MIRROR) || (_SUPPORT_STALLDET_BZC == FALSE))
l_AdcResult.u16AdcCurrB = Get_CurrentZeroOffset();
#endif
}
uint16_t ADC_GetNewSampleVsupply(void)
{
uint16_t u16Vsupply;
static const ADC_SDATA_t VS = C_ADC_VS_EOC;
if (l_u8AdcMode == C_ADC_MODE_RUN_HW)
{
#if (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM) && (_SUPPORT_APP_TYPE != C_APP_SOLENOID)
u16Vsupply = l_AdcResult.u16AdcVs_1;
#else
u16Vsupply = l_AdcResult.u16AdcVs;
#endif
}
else
{
uint16_t *pu16Src = &l_au16AdcSource[0];
#if (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM) && (_SUPPORT_APP_TYPE != C_APP_SOLENOID)
*pu16Src++ = (uint16_t)&l_AdcResult.u16AdcVs_1;
#else
*pu16Src++ = (uint16_t)&l_AdcResult.u16AdcVs;
#endif
*pu16Src++ = VS.u16;
*pu16Src = C_ADC_EOS;
(void)HAL_ADC_StartSoftTrig(C_ADC_STATE_IDLE);
#if (_SUPPORT_PWM_MODE == SINGLE_COIL_PWM) && (_SUPPORT_APP_TYPE != C_APP_SOLENOID)
u16Vsupply = l_AdcResult.u16AdcVs_1;
#else
u16Vsupply = l_AdcResult.u16AdcVs;
#endif
}
return (u16Vsupply);
}
#if (ANA_COMM != FALSE)
uint16_t ADC_ReferencePosition(void)
{
uint16_t u16NewRefPos = l_AdcResult.u16AdcRefPos;
if ( (u16NewRefPos != C_ADC_MIN) && (u16NewRefPos != C_ADC_MAX) )
{
uint16_t *pu16Pos = &l_au16PosRefSamples[l_u16PosRefMovAgvIdx];
uint16_t u16PrevPos = *pu16Pos;
l_u16PosRefMovAgvIdx = (l_u16PosRefMovAgvIdx + 1U) & (C_POS_MOVAVG_SZ - 1U);
l_u16PosRefMovAvgxN -= u16PrevPos;
l_u16PosRefMovAvgxN += u16NewRefPos;
*pu16Pos = u16NewRefPos;
g_u16ReferencePotiPos = (l_u16PosRefMovAvgxN + (C_POS_MOVAVG_SZ / 2U)) >> C_POS_MOVAVG_SSZ;
}
return (g_u16ReferencePotiPos);
}
#endif
#if ((_SUPPORT_POTI != FALSE) && (_SUPPORT_POTI_MODE == C_POTI_MODE_CLOSED_LOOP)) || (ANA_COMM != FALSE)
void ADC_ActRefPositionInit(void)
{
static const ADC_SDATA_t SBASE_ADC_POS[] =
{
C_ADC_VS_EOC,
#if (_SUPPORT_POTI != FALSE)
C_ADC_IO3_LV_EOC,
#endif
#if (ANA_COMM != FALSE) && (C_ANA_IO == PIN_FUNC_IO_0)
C_ADC_IO0_HV_EOC,
#endif
};
ADC_POS AdcPos;
#if (_SUPPORT_POTI != FALSE) && (ANA_COMM != FALSE)
uint16_t u16Done = 0x0000U;
#endif
HAL_ADC_StopSafe();
{
uint16_t *pu16Src = &l_au16AdcSource[0U];
*pu16Src++ = (uint16_t)&AdcPos.u16AdcVs;
*pu16Src++ = SBASE_ADC_POS[0].u16;
#if (_SUPPORT_POTI != FALSE)
*pu16Src++ = SBASE_ADC_POS[1].u16;
#endif
#if (ANA_COMM != FALSE) && (C_ANA_IO == PIN_FUNC_IO_0)
*pu16Src++ = SBASE_ADC_POS[2].u16;
#endif
*pu16Src = C_ADC_EOS;
}
do
{
uint16_t u16NewPos;
DELAY(C_DELAY_1MS);
HAL_ADC_Setup(
C_ADC_ASB_NEVER |
#if (_DEBUG_IO_ADC != FALSE)
C_ADC_INT_SCHEME_EOC |
#else
C_ADC_INT_SCHEME_NOINT |
#endif
B_ADC_SATURATE |
B_ADC_NO_INTERLEAVE |
C_ADC_SOC_SOURCE_HARD_CTRIG |
C_ADC_SOS_SOURCE_SOFT_TRIG);
(void)HAL_ADC_StartSoftTrig(C_ADC_STATE_IDLE);
#if (_SUPPORT_POTI != FALSE)
#if (C_POTI_CCW == FALSE)
u16NewPos = AdcPos.u16AdcPotiPos;
#else
u16NewPos = (C_ADC_MAX - AdcPos.u16AdcPotiPos);
#endif
if ( (u16NewPos != C_ADC_MIN) && (u16NewPos != C_ADC_MAX) )
{
uint16_t *pu16Pos = &l_au16PosActSamples[l_u16PosActMovAgvIdx];
l_u16PosActMovAgvIdx = (l_u16PosActMovAgvIdx + 1U) & (C_POS_MOVAVG_SZ - 1U);
#if (ANA_COMM != FALSE)
if (l_u16PosActMovAgvIdx == 0U)
{
u16Done |= 0x0001U;
}
#endif
l_u16PosActMovAvgxN += u16NewPos;
*pu16Pos = u16NewPos;
}
#endif
#if (ANA_COMM != FALSE)
u16NewPos = AdcPos.u16AdcRefPos;
if ( (u16NewPos != C_ADC_MIN) && (u16NewPos != C_ADC_MAX) )
{
uint16_t *pu16Pos = &l_au16PosRefSamples[l_u16PosRefMovAgvIdx];
l_u16PosRefMovAgvIdx = (l_u16PosRefMovAgvIdx + 1U) & (C_POS_MOVAVG_SZ - 1U);
#if (_SUPPORT_POTI != FALSE)
if (l_u16PosRefMovAgvIdx == 0U)
{
u16Done |= 0x0002U;
}
#endif
l_u16PosRefMovAvgxN += u16NewPos;
*pu16Pos = u16NewPos;
}
#endif
#if (_SUPPORT_POTI != FALSE)
#if (ANA_COMM != FALSE)
} while (u16Done != 0x0003U);
#else
} while (l_u16PosActMovAgvIdx != 0U);
#endif
#else
} while (l_u16PosRefMovAgvIdx != 0U);
#endif
#if (_SUPPORT_POTI != FALSE)
g_u16ActualPotiPos = (l_u16PosActMovAvgxN + (C_POS_MOVAVG_SZ / 2U)) >> C_POS_MOVAVG_SSZ;
#endif
#if (ANA_COMM != FALSE)
g_u16ReferencePotiPos = (l_u16PosRefMovAvgxN + (C_POS_MOVAVG_SZ / 2U)) >> C_POS_MOVAVG_SSZ;
#endif
}
#endif
#if (_SUPPORT_POTI != FALSE)
uint16_t ADC_PotentiometerPosition(void)
{
#if (C_POTI_CCW == FALSE)
uint16_t u16NewPos = l_AdcResult.u16AdcPotiPos;
#else
uint16_t u16NewPos = (C_ADC_MAX - l_AdcResult.u16AdcPotiPos);
#endif
if ( (u16NewPos != C_ADC_MIN) && (u16NewPos != C_ADC_MAX) )
{
uint16_t *pu16Pos = &l_au16PosActSamples[l_u16PosActMovAgvIdx];
uint16_t u16PrevPos = *pu16Pos;
l_u16PosActMovAgvIdx = (l_u16PosActMovAgvIdx + 1U) & (C_POS_MOVAVG_SZ - 1U);
l_u16PosActMovAvgxN -= u16PrevPos;
l_u16PosActMovAvgxN += u16NewPos;
*pu16Pos = u16NewPos;
g_u16ActualPotiPos = (l_u16PosActMovAvgxN + (C_POS_MOVAVG_SZ / 2U)) >> C_POS_MOVAVG_SSZ;
}
return (g_u16ActualPotiPos);
}
#endif
#if (_SUPPORT_TRIAXIS_MLX9038x != FALSE)
void MeasureResolverPos(void)
{
static const ADC_SDATA_t SBASE_RESOLVER[4] =
{
{.u16 = (uint16_t)&l_AdcResult.u16Resolver_X},
C_ADC_RESOLVER_IOX_LV_EOC,
C_ADC_RESOLVER_IOY_LV_EOC,
{.u16 = C_ADC_EOS}
};
HAL_ADC_StopSafe();
{
uint16_t *pu16Src = &l_au16AdcSource[0];
ADC_SDATA_t *pu16SBase = (ADC_SDATA_t *)&SBASE_RESOLVER[0];
do
{
*pu16Src = pu16SBase->u16;
pu16Src++;
pu16SBase++;
} while (pu16SBase < (ADC_SDATA_t *)&SBASE_RESOLVER[sizeof(SBASE_RESOLVER) / sizeof(uint16_t)]);
}
(void)HAL_ADC_StartSoftTrig(C_ADC_STATE_IDLE);
}
uint16_t GetResolverPosition(void)
{
uint16_t u16Result = C_ERR_NONE;
#if (_DEBUG_RESOLVER != FALSE)
static uint16_t l_u16PrevAngle = 0U;
static uint16_t l_u16PrevResolverPosX = 512U;
static uint16_t l_u16PrevResolverPosY = 512U;
static uint8_t l_u8ResolverPosErrorCnt = 0U;
#endif
g_u16ResolverPosX = l_AdcResult.u16Resolver_X;
g_u16ResolverPosY = l_AdcResult.u16Resolver_Y;
if ( ((g_u16ResolverPosX < C_ADC_RESOLVER_MIN) || (g_u16ResolverPosX > C_ADC_RESOLVER_MAX)) ||
((g_u16ResolverPosY < C_ADC_RESOLVER_MIN) || (g_u16ResolverPosY > C_ADC_RESOLVER_MAX)) )
{
u16Result = (C_ERR_TRIAXIS_INTERFACE | (C_ERR_EXT | 0x0A00U));
#if (_SUPPORT_LOG_ERRORS != FALSE)
SetLastError(u16Result);
#endif
g_e8ErrorElectric |= (uint8_t)C_ERR_SENSOR;
}
#if (_DEBUG_RESOLVER != FALSE)
while (g_u8ResolverCalibrated != FALSE)
{
int16_t i16Y =
(int16_t)(p_MulI32_I16byI16( (int16_t)(g_u16ResolverPosY - g_u16ResolverOffY),
(int16_t)g_u16ResolverAmplXY) >> 10);
int16_t i16X = (int16_t)(g_u16ResolverPosX - g_u16ResolverOffX);
uint16_t u16Angle = (uint16_t)p_atan2I16(i16Y, i16X);
uint16_t u16ResolverPosDiff;
if (g_u16ResolverPosX > l_u16PrevResolverPosX)
{
u16ResolverPosDiff = g_u16ResolverPosX - l_u16PrevResolverPosX;
}
else
{
u16ResolverPosDiff = l_u16PrevResolverPosX - g_u16ResolverPosX;
}
l_u16PrevResolverPosX = g_u16ResolverPosX;
if (u16ResolverPosDiff > 100U)
{
l_u8ResolverPosErrorCnt++;
if (l_u8ResolverPosErrorCnt > 3U)
{
u16Result = C_ERR_TRIAXIS_X_CLIP;
#if (_SUPPORT_LOG_ERRORS != FALSE)
SetLastError(u16Result);
#endif
g_e8ErrorElectric |= (uint8_t)C_ERR_SENSOR;
}
break;
}
if (g_u16ResolverPosY > l_u16PrevResolverPosY)
{
u16ResolverPosDiff = g_u16ResolverPosY - l_u16PrevResolverPosY;
}
else
{
u16ResolverPosDiff = l_u16PrevResolverPosY - g_u16ResolverPosY;
}
l_u16PrevResolverPosY = g_u16ResolverPosY;
if (u16ResolverPosDiff > 100U)
{
l_u8ResolverPosErrorCnt++;
if (l_u8ResolverPosErrorCnt > 3U)
{
u16Result = C_ERR_TRIAXIS_Y_CLIP;
#if (_SUPPORT_LOG_ERRORS != FALSE)
SetLastError(u16Result);
#endif
g_e8ErrorElectric |= (uint8_t)C_ERR_SENSOR;
}
break;
}
if (g_e8MotorDirectionCCW == FALSE)
{
if (u16Angle < l_u16PrevAngle)
{
l_u8ResolverPosErrorCnt++;
if (l_u8ResolverPosErrorCnt > 3U)
{
u16Result = C_ERR_TRIAXIS_DEADZONE_CW;
#if (_SUPPORT_LOG_ERRORS != FALSE)
SetLastError(u16Result);
#endif
g_e8ErrorElectric |= (uint8_t)C_ERR_SENSOR;
}
}
else
{
p_DecNzU8(&l_u8ResolverPosErrorCnt);
}
}
else
{
if (u16Angle > l_u16PrevAngle)
{
l_u8ResolverPosErrorCnt++;
if (l_u8ResolverPosErrorCnt > 3U)
{
u16Result = C_ERR_TRIAXIS_DEADZONE_CCW;
#if (_SUPPORT_LOG_ERRORS != FALSE)
SetLastError(u16Result);
#endif
g_e8ErrorElectric |= (uint8_t)C_ERR_SENSOR;
}
}
else
{
p_DecNzU8(&l_u8ResolverPosErrorCnt);
}
}
l_u16PrevAngle = u16Angle;
break;
}
#endif
return (u16Result);
}
#endif
#if (ANA_COMM != FALSE)
int16_t GetVio(void)
{
return ((int16_t) (l_AdcResult.u16AdcIO - Get_LowVoltOffset()));
}
#endif