/**
 * @file
 * @brief EEPROM definition file
 * @internal
 *
 * @copyright (C) 2021 Melexis N.V.
 * git flash d0014c23
 *
 * Melexis N.V. is supplying this code for use with Melexis N.V. processor based microcontrollers only.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.  MELEXIS N.V. SHALL NOT IN ANY CIRCUMSTANCES,
 * BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * @endinternal
 *
 * @details
 * This file was autogenerated. The information of the source is described below:
 * Tag: 1.96
 * This file was autogenerated. The information of the source is described below:
 * Tag: 1.22
 * Automatic generation by MlxCCT 1.24
 * Template version 2.0.3
 *
 * File sections:
 * 1 General for use macros
 * 2 Auxillary macros
 * 3 EEPROM declarations:
 * 3.1 Hosting variables
 * 3.2 Get macros
 * 3.3 Variables
 * 3.4 Dummy ports
 * 4 Summary
 */

#ifndef EEPROM_PARAMETERS_H
#define EEPROM_PARAMETERS_H

#include <stdint.h>
#include "memory_map.h"

/*****************************************************************************/
/* 1. General macros. */

/** Getter for EE parameter
 *
 * Get an EEPROM bit field.
 * @param FIELD the field to read.
 */

#ifndef EE_GET
#define EE_GET(FIELD) EE_ ## FIELD ## _GET ()
#endif

/** Setter for EE parameter

 * Set one or multiple EEPROM bit fields to some values. The number of fields set
 * has to be one or more, maximum 16.
 *
 * Usage:
 * \li EE_SET(FIELD1, VALUE1) <br>
 * \li EE_SET(FIELD1, VALUE1, FIELD2, VALUE2, ..., FIELD16, VALUE16) <br>
 *
 * where FIELDx, is the field to set, and VALUEx, is the value of the field to set (should be in the valid range).
 *
 * @note In most cases this can only be used for unit testing, as the EEPROM is not always writable and variables
 * are declared to be constant.
 * @param ... Alternating sequence of FIELDx and VALUEx pairs, see above example
 */
#ifndef EE_SET
#define EE_SET(...) \
    CCT_EE_SET (__VA_ARGS__, \
        DUMMY2,  0U, DUMMY3,  0U, DUMMY4,  0U, DUMMY5,  0U,  DUMMY6, 0U, \
        DUMMY7,  0U, DUMMY8,  0U, DUMMY9,  0U, DUMMY10, 0U, DUMMY11, 0U, \
        DUMMY12, 0U, DUMMY13, 0U, DUMMY14, 0U, DUMMY15, 0U, DUMMY16, 0U, \
        DUMMY17, 0U)
#endif

/*****************************************************************************/
/* 2. Auxillary (helper) macros. */
/* These macros are subject to change without notice! */

/* TODO: Optimize to always setb/clrb. */

#define CCT_EE_SET(\
        F1,  V1,  F2,  V2,  F3,  V3,  F4,  V4,  F5,  V5,  F6,  V6,  \
        F7,  V7,  F8,  V8,  F9,  V9,  F10, V10, F11, V11, F12, V12, \
        F13, V13, F14, V14, F15, V15, F16, V16, F17, V17, \
        ...) \
    if (EE_BIT_ACCESSIBLE (\
                           F1,  F2,  F3,  F4,  F5,  F6,  F7,  F8,  \
                           F9, F10, F11, F12, F13, F14, F15, F16)) \
    { \
        if (EE_BIT_ACCESSIBLE (F1)) { \
            if (V1) EE_HOST (F1) |=  EE_MASK (F1); \
            else    EE_HOST (F1) &= ~EE_MASK (F1); \
        } \
        if (!EE_DUMMY (F2) && EE_BIT_ACCESSIBLE (F2)) { \
            if (V2) EE_HOST (F2) |=  EE_MASK (F2); \
            else    EE_HOST (F2) &= ~EE_MASK (F2); \
        } \
        if (!EE_DUMMY (F3) && EE_BIT_ACCESSIBLE (F3)) { \
            if (V3) EE_HOST (F3) |=  EE_MASK (F3); \
            else    EE_HOST (F3) &= ~EE_MASK (F3); \
        } \
        if (!EE_DUMMY (F4) && EE_BIT_ACCESSIBLE (F4)) { \
            if (V4) EE_HOST (F4) |=  EE_MASK (F4); \
            else    EE_HOST (F4) &= ~EE_MASK (F4); \
        } \
        if (!EE_DUMMY (F5) && EE_BIT_ACCESSIBLE (F5)) { \
            if (V5) EE_HOST (F5) |=  EE_MASK (F5); \
            else    EE_HOST (F5) &= ~EE_MASK (F5); \
        } \
        if (!EE_DUMMY (F6) && EE_BIT_ACCESSIBLE (F6)) { \
            if (V6) EE_HOST (F6) |=  EE_MASK (F6); \
            else    EE_HOST (F6) &= ~EE_MASK (F6); \
        } \
        if (!EE_DUMMY (F7) && EE_BIT_ACCESSIBLE (F7)) { \
            if (V7) EE_HOST (F7) |=  EE_MASK (F7); \
            else    EE_HOST (F7) &= ~EE_MASK (F7); \
        } \
        if (!EE_DUMMY (F8) && EE_BIT_ACCESSIBLE (F8)) { \
            if (V8) EE_HOST (F8) |=  EE_MASK (F8); \
            else    EE_HOST (F8) &= ~EE_MASK (F8); \
        } \
        if (!EE_DUMMY (F9) && EE_BIT_ACCESSIBLE (F9)) { \
            if (V9) EE_HOST (F9) |=  EE_MASK (F9); \
            else    EE_HOST (F9) &= ~EE_MASK (F9); \
        } \
        if (!EE_DUMMY (F10) && EE_BIT_ACCESSIBLE (F10)) { \
            if (V10) EE_HOST (F10) |=  EE_MASK (F10); \
            else    EE_HOST (F10) &= ~EE_MASK (F10); \
        } \
        if (!EE_DUMMY (F11) && EE_BIT_ACCESSIBLE (F11)) { \
            if (V11) EE_HOST (F11) |=  EE_MASK (F11); \
            else    EE_HOST (F11) &= ~EE_MASK (F11); \
        } \
        if (!EE_DUMMY (F12) && EE_BIT_ACCESSIBLE (F12)) { \
            if (V12) EE_HOST (F12) |=  EE_MASK (F12); \
            else    EE_HOST (F12) &= ~EE_MASK (F12); \
        } \
        if (!EE_DUMMY (F13) && EE_BIT_ACCESSIBLE (F13)) { \
            if (V13) EE_HOST (F13) |=  EE_MASK (F13); \
            else    EE_HOST (F13) &= ~EE_MASK (F13); \
        } \
        if (!EE_DUMMY (F14) && EE_BIT_ACCESSIBLE (F14)) { \
            if (V14) EE_HOST (F14) |=  EE_MASK (F14); \
            else    EE_HOST (F14) &= ~EE_MASK (F14); \
        } \
        if (!EE_DUMMY (F15) && EE_BIT_ACCESSIBLE (F15)) { \
            if (V15) EE_HOST (F15) |=  EE_MASK (F15); \
            else    EE_HOST (F15) &= ~EE_MASK (F15); \
        } \
        if (!EE_DUMMY (F16) && EE_BIT_ACCESSIBLE (F16)) { \
            if (V16) EE_HOST (F16) |=  EE_MASK (F16); \
            else    EE_HOST (F16) &= ~EE_MASK (F16); \
        } \
    } \
    else if ((EE_HOST_UNUSED (F1) | EE_MASK (\
                    F1, F2, F3, F4, F5, F6, F7, F8, \
                    F9, F10, F11, F12, F13, F14, F15, F16)) == 0xFFFFU) {\
        EE_HOST (F1) = \
          ((V1 ) << EE_OFFSET (F1 )) | ((V2 ) << EE_OFFSET (F2 ))\
        | ((V3 ) << EE_OFFSET (F3 )) | ((V4 ) << EE_OFFSET (F4 ))\
        | ((V5 ) << EE_OFFSET (F5 )) | ((V6 ) << EE_OFFSET (F6 ))\
        | ((V7 ) << EE_OFFSET (F7 )) | ((V8 ) << EE_OFFSET (F8 ))\
        | ((V9 ) << EE_OFFSET (F9 )) | ((V10) << EE_OFFSET (F10))\
        | ((V11) << EE_OFFSET (F11)) | ((V12) << EE_OFFSET (F12))\
        | ((V13) << EE_OFFSET (F13)) | ((V14) << EE_OFFSET (F14))\
        | ((V15) << EE_OFFSET (F15)) | ((V16) << EE_OFFSET (F16))\
            ; \
    } \
    else { \
        EE_HOST (F1) = (EE_HOST (F1) \
            & ~EE_MASK (\
                    F1, F2, F3, F4, F5, F6, F7, F8,   \
                    F9, F10, F11, F12, F13, F14, F15, F16)) \
        | ((V1 ) << EE_OFFSET (F1 )) | ((V2 ) << EE_OFFSET (F2 ))\
        | ((V3 ) << EE_OFFSET (F3 )) | ((V4 ) << EE_OFFSET (F4 ))\
        | ((V5 ) << EE_OFFSET (F5 )) | ((V6 ) << EE_OFFSET (F6 ))\
        | ((V7 ) << EE_OFFSET (F7 )) | ((V8 ) << EE_OFFSET (F8 ))\
        | ((V9 ) << EE_OFFSET (F9 )) | ((V10) << EE_OFFSET (F10))\
        | ((V11) << EE_OFFSET (F11)) | ((V12) << EE_OFFSET (F12))\
        | ((V13) << EE_OFFSET (F13)) | ((V14) << EE_OFFSET (F14))\
        | ((V15) << EE_OFFSET (F15)) | ((V16) << EE_OFFSET (F16))\
            ; \
    } \
    EE_ASSERT_WRITABLES (\
            F1, F2, F3, F4, F5, F6, F7, F8, \
            F9, F10, F11, F12, F13, F14, F15, F16); \
    EE_ASSERT_SAME_HOST (\
            F1, F2, F3, F4, F5, F6, F7, F8, \
            F9, F10, F11, F12, F13, F14, F15, F16); \
    EE_ASSERT_ARGS_FIT  (\
            F1, F2, F3, F4, F5, F6, F7, F8, \
            F9, F10, F11, F12, F13, F14, F15, F16, F17);

/** Return a dereferenced pointer to the address where a given field resides.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_HOST(FIELD)  CCT_EE_HOST2 (EE_ ## FIELD)
#define CCT_EE_HOST2(F)   CCT_EE_HOST3 (F)
#define CCT_EE_HOST3(...) CCT_EE_HOST4 (__VA_ARGS__)
#define CCT_EE_HOST4(H, A, BA, M, O, W, B, U) (H)

/** Return the word address where the given field resides.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_ADDRESS(FIELD)  CCT_EE_ADDRESS2 (EE_ ## FIELD)
#define CCT_EE_ADDRESS2(F)   CCT_EE_ADDRESS3 (F)
#define CCT_EE_ADDRESS3(...) CCT_EE_ADDRESS4 (__VA_ARGS__)
#define CCT_EE_ADDRESS4(H, A, BA, M, O, W, B, U) (A)

/** Return the byte address where the given field resides.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_BYTE_ADDRESS(FIELD)  CCT_EE_BYTE_ADDRESS2 (EE_ ## FIELD)
#define CCT_EE_BYTE_ADDRESS2(F)   CCT_EE_BYTE_ADDRESS3 (F)
#define CCT_EE_BYTE_ADDRESS3(...) CCT_EE_BYTE_ADDRESS4 (__VA_ARGS__)
#define CCT_EE_BYTE_ADDRESS4(H, A, BA, M, O, W, B, U) (BA)

/** Get a mask of all unused host bits for giveb field field.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_HOST_UNUSED(FIELD)  CCT_EE_HOST_UNUSED2 (EE_ ## FIELD)
#define CCT_EE_HOST_UNUSED2(F)   CCT_EE_HOST_UNUSED3 (F)
#define CCT_EE_HOST_UNUSED3(...) CCT_EE_HOST_UNUSED4 (__VA_ARGS__)
#define CCT_EE_HOST_UNUSED4(H, A, BA, M, O, W, B, U) (U)

/** Get the bit offset from where the given field begins in its host.
 *
 * @param FIELD Field to retrieve the information for
 */

#define EE_OFFSET(FIELD)  CCT_EE_OFFSET2 (EE_ ## FIELD)
#define CCT_EE_OFFSET2(F)   CCT_EE_OFFSET3 (F)
#define CCT_EE_OFFSET3(...) CCT_EE_OFFSET4 (__VA_ARGS__)
#define CCT_EE_OFFSET4(H, A, BA, M, O, W, B, U) (O)

/** Checks whether the given field is dummy one i.e. it is a MlxCCT private.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_DUMMY(FIELD)  CCT_EE_DUMMY2 (EE_ ## FIELD)
#define CCT_EE_DUMMY2(F)   CCT_EE_DUMMY3 (F)
#define CCT_EE_DUMMY3(...) CCT_EE_DUMMY4 (__VA_ARGS__)
#define CCT_EE_DUMMY4(H, A, BA, M, O, W, B, U) (B == 2U)

/** Checks whether the given fields can be bit accessed (setb, clrb, ...).
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_BIT_ACCESSIBLE(FIELD, ...) \
    CCT_EE_BIT_ACCESSIBLE2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16)
#define CCT_EE_BIT_ACCESSIBLE2(F1, F2, F3, F4, F5, F6, F7, F8,  \
                            F9, F10, F11, F12, F13, F14, F15, F16, ...) \
    (  CCT_EE_BIT_ACCESSIBLE3 (EE_##F1 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F2 )\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F3 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F4 )\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F5 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F6 )\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F7 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F8 )\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F9 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F10)\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F11) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F12)\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F13) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F14)\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F15) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F16))
#define CCT_EE_BIT_ACCESSIBLE3(...) CCT_EE_BIT_ACCESSIBLE4 (__VA_ARGS__)
#define CCT_EE_BIT_ACCESSIBLE4(H, A, BA, M, O, W, B, U) (B)

/** Get a compound mask for all the given fields.
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_MASK(FIELD, ...) \
    CCT_EE_MASK2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16)
#define CCT_EE_MASK2(F1, F2, F3, F4, F5, F6, F7, F8, \
                  F9, F10, F11, F12, F13, F14, F15, F16, ...) \
    ( CCT_EE_MASK3 (EE_ ## F1 ) | CCT_EE_MASK3 (EE_ ## F2 ) \
    | CCT_EE_MASK3 (EE_ ## F3 ) | CCT_EE_MASK3 (EE_ ## F4 ) \
    | CCT_EE_MASK3 (EE_ ## F5 ) | CCT_EE_MASK3 (EE_ ## F6 ) \
    | CCT_EE_MASK3 (EE_ ## F7 ) | CCT_EE_MASK3 (EE_ ## F8 ) \
    | CCT_EE_MASK3 (EE_ ## F9 ) | CCT_EE_MASK3 (EE_ ## F10) \
    | CCT_EE_MASK3 (EE_ ## F11) | CCT_EE_MASK3 (EE_ ## F12) \
    | CCT_EE_MASK3 (EE_ ## F13) | CCT_EE_MASK3 (EE_ ## F14) \
    | CCT_EE_MASK3 (EE_ ## F15) | CCT_EE_MASK3 (EE_ ## F16))
#define CCT_EE_MASK3(...) CCT_EE_MASK4 (__VA_ARGS__)
#define CCT_EE_MASK4(H, A, BA, M, O, W, B, U) (M)

/** Type of somewhat expressive, compile-time check.
 *
 * @param MSG Error message
 * @param EXPR Expression to assert
 */
#define EE_STATIC_ASSERT(MSG, EXPR) { enum { MSG = 1/(!!(EXPR)) }; }

/** Compile time assert that the given fields can be written.
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_ASSERT_WRITABLES(FIELD, ...) \
    CCT_EE_WRITABLES2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16)
#define CCT_EE_WRITABLES2(F1, F2, F3, F4, F5, F6, F7, F8, \
                       F9, F10, F11, F12, F13, F14, F15, F16, ...) \
    CCT_EE_WRITABLES3 (F1 , EE_##F1 ) CCT_EE_WRITABLES3 (F2 , EE_##F2 ) \
    CCT_EE_WRITABLES3 (F3 , EE_##F3 ) CCT_EE_WRITABLES3 (F4 , EE_##F4 ) \
    CCT_EE_WRITABLES3 (F5 , EE_##F5 ) CCT_EE_WRITABLES3 (F6 , EE_##F6 ) \
    CCT_EE_WRITABLES3 (F7 , EE_##F7 ) CCT_EE_WRITABLES3 (F8 , EE_##F8 ) \
    CCT_EE_WRITABLES3 (F9 , EE_##F9 ) CCT_EE_WRITABLES3 (F10, EE_##F10) \
    CCT_EE_WRITABLES3 (F11, EE_##F11) CCT_EE_WRITABLES3 (F12, EE_##F12) \
    CCT_EE_WRITABLES3 (F13, EE_##F13) CCT_EE_WRITABLES3 (F14, EE_##F14) \
    CCT_EE_WRITABLES3 (F15, EE_##F15) CCT_EE_WRITABLES3 (F16, EE_##F16)
#define CCT_EE_WRITABLES3(...) CCT_EE_WRITABLES4 (__VA_ARGS__)
#define CCT_EE_WRITABLES4(F, H, A, BA, M, O, W, B, U) \
    EE_STATIC_ASSERT (F ## _IS_WRITABLE, W)

/** Compile time assert that the given fields share the same host.
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_ASSERT_SAME_HOST(FIELD, ...) \
    CCT_EE_SAME_HOST2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16)
#define CCT_EE_SAME_HOST2(F1, F2, F3, F4, F5, F6, F7, F8, \
                       F9, F10, F11, F12, F13, F14, F15, F16, ...) \
    EE_STATIC_ASSERT (FIELDS_SHARE_SAME_ADDRESS, \
       (EE_DUMMY (F2 ) || EE_ADDRESS (F1) == EE_ADDRESS (F2 )) \
    && (EE_DUMMY (F3 ) || EE_ADDRESS (F1) == EE_ADDRESS (F3 )) \
    && (EE_DUMMY (F4 ) || EE_ADDRESS (F1) == EE_ADDRESS (F4 )) \
    && (EE_DUMMY (F5 ) || EE_ADDRESS (F1) == EE_ADDRESS (F5 )) \
    && (EE_DUMMY (F6 ) || EE_ADDRESS (F1) == EE_ADDRESS (F6 )) \
    && (EE_DUMMY (F7 ) || EE_ADDRESS (F1) == EE_ADDRESS (F7 )) \
    && (EE_DUMMY (F8 ) || EE_ADDRESS (F1) == EE_ADDRESS (F8 )) \
    && (EE_DUMMY (F9 ) || EE_ADDRESS (F1) == EE_ADDRESS (F9 )) \
    && (EE_DUMMY (F10) || EE_ADDRESS (F1) == EE_ADDRESS (F10)) \
    && (EE_DUMMY (F11) || EE_ADDRESS (F1) == EE_ADDRESS (F11)) \
    && (EE_DUMMY (F12) || EE_ADDRESS (F1) == EE_ADDRESS (F12)) \
    && (EE_DUMMY (F13) || EE_ADDRESS (F1) == EE_ADDRESS (F13)) \
    && (EE_DUMMY (F14) || EE_ADDRESS (F1) == EE_ADDRESS (F14)) \
    && (EE_DUMMY (F15) || EE_ADDRESS (F1) == EE_ADDRESS (F15)) \
    && (EE_DUMMY (F16) || EE_ADDRESS (F1) == EE_ADDRESS (F16)))

/** Assert whether these arguments fits in the EE_ macros.
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_ASSERT_ARGS_FIT(FIELD, ...) \
    CCT_EE_ASSERT_ARGS_FIT2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16, DUMMY17)
#define CCT_EE_ASSERT_ARGS_FIT2(F1, F2, F3, F4, F5, F6, F7, F8, \
                    F9, F10, F11, F12, F13, F14, F15, F16, F17, ...) \
    CCT_EE_ASSERT_ARGS_FIT3 (EE_ ## F17)
#define CCT_EE_ASSERT_ARGS_FIT3(...) CCT_EE_ASSERT_ARGS_FIT4 (__VA_ARGS__)
#define CCT_EE_ASSERT_ARGS_FIT4(H, A, BA, M, O, W, B, U) \
    EE_STATIC_ASSERT (ARGUMENTS_FIT_IN_MACRO, B == 2U)

/*****************************************************************************/
/* 3. EEPROM declarations. */

/*****************************************************************************/
/* 3.1 Hosting variables. */

extern uint16_t ee0x400 __attribute__((ep, addr(MEM_EEPROM_START + 0x0000u)));
extern uint16_t ee0x402 __attribute__((ep, addr(MEM_EEPROM_START + 0x0002u)));
extern uint16_t ee0x404 __attribute__((ep, addr(MEM_EEPROM_START + 0x0004u)));
extern uint16_t ee0x406 __attribute__((ep, addr(MEM_EEPROM_START + 0x0006u)));
extern uint16_t ee0x408 __attribute__((ep, addr(MEM_EEPROM_START + 0x0008u)));
extern uint16_t ee0x40a __attribute__((ep, addr(MEM_EEPROM_START + 0x000au)));
extern uint16_t ee0x40c __attribute__((ep, addr(MEM_EEPROM_START + 0x000cu)));
extern uint16_t ee0x40e __attribute__((ep, addr(MEM_EEPROM_START + 0x000eu)));
extern uint16_t ee0x410 __attribute__((ep, addr(MEM_EEPROM_START + 0x0010u)));
extern uint16_t ee0x412 __attribute__((ep, addr(MEM_EEPROM_START + 0x0012u)));
extern uint16_t ee0x414 __attribute__((ep, addr(MEM_EEPROM_START + 0x0014u)));
extern uint16_t ee0x416 __attribute__((ep, addr(MEM_EEPROM_START + 0x0016u)));
extern uint16_t ee0x418 __attribute__((ep, addr(MEM_EEPROM_START + 0x0018u)));
extern uint16_t ee0x41a __attribute__((ep, addr(MEM_EEPROM_START + 0x001au)));
extern uint16_t ee0x41c __attribute__((ep, addr(MEM_EEPROM_START + 0x001cu)));
extern uint16_t ee0x41e __attribute__((ep, addr(MEM_EEPROM_START + 0x001eu)));
extern uint16_t ee0x420 __attribute__((ep, addr(MEM_EEPROM_START + 0x0020u)));
extern uint16_t ee0x422 __attribute__((ep, addr(MEM_EEPROM_START + 0x0022u)));
extern uint16_t ee0x424 __attribute__((ep, addr(MEM_EEPROM_START + 0x0024u)));
extern uint16_t ee0x426 __attribute__((ep, addr(MEM_EEPROM_START + 0x0026u)));
extern uint16_t ee0x428 __attribute__((ep, addr(MEM_EEPROM_START + 0x0028u)));
extern uint16_t ee0x42a __attribute__((ep, addr(MEM_EEPROM_START + 0x002au)));
extern uint16_t ee0x42c __attribute__((ep, addr(MEM_EEPROM_START + 0x002cu)));
extern uint16_t ee0x42e __attribute__((ep, addr(MEM_EEPROM_START + 0x002eu)));
extern uint16_t ee0x430 __attribute__((ep, addr(MEM_EEPROM_START + 0x0030u)));
extern uint16_t ee0x432 __attribute__((ep, addr(MEM_EEPROM_START + 0x0032u)));
extern uint16_t ee0x434 __attribute__((ep, addr(MEM_EEPROM_START + 0x0034u)));
extern uint16_t ee0x436 __attribute__((ep, addr(MEM_EEPROM_START + 0x0036u)));
extern uint16_t ee0x438 __attribute__((ep, addr(MEM_EEPROM_START + 0x0038u)));
extern uint16_t ee0x43a __attribute__((ep, addr(MEM_EEPROM_START + 0x003au)));
extern uint16_t ee0x43c __attribute__((ep, addr(MEM_EEPROM_START + 0x003cu)));
extern uint16_t ee0x43e __attribute__((ep, addr(MEM_EEPROM_START + 0x003eu)));
extern uint16_t ee0x5b0 __attribute__((addr(MEM_EEPROM_START + 0x01b0u)));
extern uint16_t ee0x5b2 __attribute__((addr(MEM_EEPROM_START + 0x01b2u)));
extern uint16_t ee0x5b4 __attribute__((addr(MEM_EEPROM_START + 0x01b4u)));
extern uint16_t ee0x5b6 __attribute__((addr(MEM_EEPROM_START + 0x01b6u)));
extern uint16_t ee0x5b8 __attribute__((addr(MEM_EEPROM_START + 0x01b8u)));
extern uint16_t ee0x5ba __attribute__((addr(MEM_EEPROM_START + 0x01bau)));
extern uint16_t ee0x5bc __attribute__((addr(MEM_EEPROM_START + 0x01bcu)));
extern uint16_t ee0x5be __attribute__((addr(MEM_EEPROM_START + 0x01beu)));
extern uint16_t ee0x5c0 __attribute__((addr(MEM_EEPROM_START + 0x01c0u)));
extern uint16_t ee0x5c2 __attribute__((addr(MEM_EEPROM_START + 0x01c2u)));
extern uint16_t ee0x5c4 __attribute__((addr(MEM_EEPROM_START + 0x01c4u)));
extern uint16_t ee0x5c6 __attribute__((addr(MEM_EEPROM_START + 0x01c6u)));
extern uint16_t ee0x5c8 __attribute__((addr(MEM_EEPROM_START + 0x01c8u)));
extern uint16_t ee0x5ca __attribute__((addr(MEM_EEPROM_START + 0x01cau)));
extern uint16_t ee0x5cc __attribute__((addr(MEM_EEPROM_START + 0x01ccu)));
extern uint16_t ee0x5ce __attribute__((addr(MEM_EEPROM_START + 0x01ceu)));
extern uint16_t ee0x5d0 __attribute__((addr(MEM_EEPROM_START + 0x01d0u)));
extern uint16_t ee0x5d2 __attribute__((addr(MEM_EEPROM_START + 0x01d2u)));
extern uint16_t ee0x5d4 __attribute__((addr(MEM_EEPROM_START + 0x01d4u)));
extern uint16_t ee0x5d6 __attribute__((addr(MEM_EEPROM_START + 0x01d6u)));
extern uint16_t ee0x5d8 __attribute__((addr(MEM_EEPROM_START + 0x01d8u)));
extern uint16_t ee0x5da __attribute__((addr(MEM_EEPROM_START + 0x01dau)));
extern uint16_t ee0x5dc __attribute__((addr(MEM_EEPROM_START + 0x01dcu)));
extern uint16_t ee0x5de __attribute__((addr(MEM_EEPROM_START + 0x01deu)));
extern uint16_t ee0x5e0 __attribute__((addr(MEM_EEPROM_START + 0x01e0u)));
extern uint16_t ee0x5e2 __attribute__((addr(MEM_EEPROM_START + 0x01e2u)));
extern uint16_t ee0x5e4 __attribute__((addr(MEM_EEPROM_START + 0x01e4u)));
extern uint16_t ee0x5e6 __attribute__((addr(MEM_EEPROM_START + 0x01e6u)));
extern uint16_t ee0x5e8 __attribute__((addr(MEM_EEPROM_START + 0x01e8u)));
extern uint16_t ee0x5ea __attribute__((addr(MEM_EEPROM_START + 0x01eau)));
extern uint16_t ee0x5ec __attribute__((addr(MEM_EEPROM_START + 0x01ecu)));
extern uint16_t ee0x5ee __attribute__((addr(MEM_EEPROM_START + 0x01eeu)));
extern uint16_t ee0x5f0 __attribute__((addr(MEM_EEPROM_START + 0x01f0u)));
extern uint16_t ee0x5f2 __attribute__((addr(MEM_EEPROM_START + 0x01f2u)));
extern uint16_t ee0x5f4 __attribute__((addr(MEM_EEPROM_START + 0x01f4u)));
extern uint16_t ee0x5f6 __attribute__((addr(MEM_EEPROM_START + 0x01f6u)));
extern uint16_t ee0x5f8 __attribute__((addr(MEM_EEPROM_START + 0x01f8u)));
extern uint16_t ee0x5fa __attribute__((addr(MEM_EEPROM_START + 0x01fau)));
extern uint16_t ee0x5fc __attribute__((addr(MEM_EEPROM_START + 0x01fcu)));
extern uint16_t ee0x5fe __attribute__((addr(MEM_EEPROM_START + 0x01feu)));
extern uint16_t ee0x600 __attribute__((addr(MEM_EEPROM_START + 0x0200u)));
extern uint16_t ee0x602 __attribute__((addr(MEM_EEPROM_START + 0x0202u)));
extern uint16_t ee0x604 __attribute__((addr(MEM_EEPROM_START + 0x0204u)));
extern uint16_t ee0x606 __attribute__((addr(MEM_EEPROM_START + 0x0206u)));
extern uint16_t ee0x608 __attribute__((addr(MEM_EEPROM_START + 0x0208u)));
extern uint16_t ee0x60a __attribute__((addr(MEM_EEPROM_START + 0x020au)));
extern uint16_t ee0x60c __attribute__((addr(MEM_EEPROM_START + 0x020cu)));
extern uint16_t ee0x60e __attribute__((addr(MEM_EEPROM_START + 0x020eu)));
extern uint16_t ee0x610 __attribute__((addr(MEM_EEPROM_START + 0x0210u)));
extern uint16_t ee0x612 __attribute__((addr(MEM_EEPROM_START + 0x0212u)));
extern uint16_t ee0x614 __attribute__((addr(MEM_EEPROM_START + 0x0214u)));
extern uint16_t ee0x616 __attribute__((addr(MEM_EEPROM_START + 0x0216u)));
extern uint16_t ee0x618 __attribute__((addr(MEM_EEPROM_START + 0x0218u)));
extern uint16_t ee0x61a __attribute__((addr(MEM_EEPROM_START + 0x021au)));
extern uint16_t ee0x61c __attribute__((addr(MEM_EEPROM_START + 0x021cu)));
extern uint16_t ee0x61e __attribute__((addr(MEM_EEPROM_START + 0x021eu)));
extern uint16_t ee0x620 __attribute__((addr(MEM_EEPROM_START + 0x0220u)));
extern uint16_t ee0x622 __attribute__((addr(MEM_EEPROM_START + 0x0222u)));
extern uint16_t ee0x624 __attribute__((addr(MEM_EEPROM_START + 0x0224u)));
extern uint16_t ee0x626 __attribute__((addr(MEM_EEPROM_START + 0x0226u)));
extern uint16_t ee0x628 __attribute__((addr(MEM_EEPROM_START + 0x0228u)));
extern uint16_t ee0x62a __attribute__((addr(MEM_EEPROM_START + 0x022au)));
extern uint16_t ee0x62c __attribute__((addr(MEM_EEPROM_START + 0x022cu)));
extern uint16_t ee0x62e __attribute__((addr(MEM_EEPROM_START + 0x022eu)));
extern uint16_t ee0x630 __attribute__((addr(MEM_EEPROM_START + 0x0230u)));
extern uint16_t ee0x632 __attribute__((addr(MEM_EEPROM_START + 0x0232u)));
extern uint16_t ee0x634 __attribute__((addr(MEM_EEPROM_START + 0x0234u)));
extern uint16_t ee0x636 __attribute__((addr(MEM_EEPROM_START + 0x0236u)));
extern uint16_t ee0x638 __attribute__((addr(MEM_EEPROM_START + 0x0238u)));
extern uint16_t ee0x63a __attribute__((addr(MEM_EEPROM_START + 0x023au)));
extern uint16_t ee0x63c __attribute__((addr(MEM_EEPROM_START + 0x023cu)));
extern uint16_t ee0x63e __attribute__((addr(MEM_EEPROM_START + 0x023eu)));

/*****************************************************************************/
/* 3.2 Get macros. */

/** PATCH_LEN : High byte : PATCH Length */
#define EE_PATCH_LEN_GET() \
    (uint8_t)((ee0x400 & 0xff00u) >> 8U)
/** PATCH_CRC : Low byte : Calculated CRC over patch addresses */
#define EE_PATCH_CRC_GET() \
    (uint8_t)((ee0x400 & 0x00ffu) >> 0U)
/** PATCH_ID : ID of the patch */
#define EE_PATCH_ID_GET() \
    (uint16_t)((ee0x402 & 0xffffu) >> 0U)
/** PATCH0_ADR : DEBUG_ADR0 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH0_ADR_GET() \
    (uint16_t)((ee0x404 & 0xffffu) >> 0U)
/** PATCH0_DATA : DEBUG_DATA0 (replacement instr) */
#define EE_PATCH0_DATA_GET() \
    (uint16_t)((ee0x406 & 0xffffu) >> 0U)
/** PATCH1_ADR : DEBUG_ADR1 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH1_ADR_GET() \
    (uint16_t)((ee0x408 & 0xffffu) >> 0U)
/** PATCH1_DATA : DEBUG_DATA1 (replacement instr) */
#define EE_PATCH1_DATA_GET() \
    (uint16_t)((ee0x40a & 0xffffu) >> 0U)
/** PATCH2_ADR : DEBUG_ADR2 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH2_ADR_GET() \
    (uint16_t)((ee0x40c & 0xffffu) >> 0U)
/** PATCH2_DATA : DEBUG_DATA2 (replacement instr) */
#define EE_PATCH2_DATA_GET() \
    (uint16_t)((ee0x40e & 0xffffu) >> 0U)
/** PATCH_CODE00 : patch code in EEPROM */
#define EE_PATCH_CODE00_GET() \
    (uint16_t)((ee0x410 & 0xffffu) >> 0U)
/** PATCH_CODE01 : patch code in EEPROM */
#define EE_PATCH_CODE01_GET() \
    (uint16_t)((ee0x412 & 0xffffu) >> 0U)
/** PATCH_CODE02 : patch code in EEPROM */
#define EE_PATCH_CODE02_GET() \
    (uint16_t)((ee0x414 & 0xffffu) >> 0U)
/** PATCH_CODE03 : patch code in EEPROM */
#define EE_PATCH_CODE03_GET() \
    (uint16_t)((ee0x416 & 0xffffu) >> 0U)
/** PATCH_CODE04 : patch code in EEPROM */
#define EE_PATCH_CODE04_GET() \
    (uint16_t)((ee0x418 & 0xffffu) >> 0U)
/** PATCH_CODE05 : patch code in EEPROM */
#define EE_PATCH_CODE05_GET() \
    (uint16_t)((ee0x41a & 0xffffu) >> 0U)
/** PATCH_CODE06 : patch code in EEPROM */
#define EE_PATCH_CODE06_GET() \
    (uint16_t)((ee0x41c & 0xffffu) >> 0U)
/** PATCH_CODE07 : patch code in EEPROM */
#define EE_PATCH_CODE07_GET() \
    (uint16_t)((ee0x41e & 0xffffu) >> 0U)
/** PATCH_CODE08 : patch code in EEPROM */
#define EE_PATCH_CODE08_GET() \
    (uint16_t)((ee0x420 & 0xffffu) >> 0U)
/** PATCH_CODE09 : patch code in EEPROM */
#define EE_PATCH_CODE09_GET() \
    (uint16_t)((ee0x422 & 0xffffu) >> 0U)
/** PATCH_CODE10 : patch code in EEPROM */
#define EE_PATCH_CODE10_GET() \
    (uint16_t)((ee0x424 & 0xffffu) >> 0U)
/** PATCH_CODE11 : patch code in EEPROM */
#define EE_PATCH_CODE11_GET() \
    (uint16_t)((ee0x426 & 0xffffu) >> 0U)
/** PATCH_CODE12 : patch code in EEPROM */
#define EE_PATCH_CODE12_GET() \
    (uint16_t)((ee0x428 & 0xffffu) >> 0U)
/** PATCH_CODE13 : patch code in EEPROM */
#define EE_PATCH_CODE13_GET() \
    (uint16_t)((ee0x42a & 0xffffu) >> 0U)
/** PATCH_CODE14 : patch code in EEPROM */
#define EE_PATCH_CODE14_GET() \
    (uint16_t)((ee0x42c & 0xffffu) >> 0U)
/** PATCH_CODE15 : patch code in EEPROM */
#define EE_PATCH_CODE15_GET() \
    (uint16_t)((ee0x42e & 0xffffu) >> 0U)
/** PATCH_CODE16 : patch code in EEPROM */
#define EE_PATCH_CODE16_GET() \
    (uint16_t)((ee0x430 & 0xffffu) >> 0U)
/** PATCH_CODE17 : patch code in EEPROM */
#define EE_PATCH_CODE17_GET() \
    (uint16_t)((ee0x432 & 0xffffu) >> 0U)
/** PATCH_CODE18 : patch code in EEPROM */
#define EE_PATCH_CODE18_GET() \
    (uint16_t)((ee0x434 & 0xffffu) >> 0U)
/** PATCH_CODE19 : patch code in EEPROM */
#define EE_PATCH_CODE19_GET() \
    (uint16_t)((ee0x436 & 0xffffu) >> 0U)
/** PATCH_CODE20 : patch code in EEPROM */
#define EE_PATCH_CODE20_GET() \
    (uint16_t)((ee0x438 & 0xffffu) >> 0U)
/** PATCH_CODE21 : patch code in EEPROM */
#define EE_PATCH_CODE21_GET() \
    (uint16_t)((ee0x43a & 0xffffu) >> 0U)
/** PATCH_CODE22 : patch code in EEPROM */
#define EE_PATCH_CODE22_GET() \
    (uint16_t)((ee0x43c & 0xffffu) >> 0U)
/** PATCH_CODE23 : patch code in EEPROM */
#define EE_PATCH_CODE23_GET() \
    (uint16_t)((ee0x43e & 0xffffu) >> 0U)
/** APP_TRIM0 : {TempMid[7:0], CalibCRC_EE[7:0]} */
#define EE_APP_TRIM0_GET() \
    (uint16_t)((ee0x5b0 & 0xffffu) >> 0U)
/** TEMPMID : Middle Temperature used in production (mostly probing1 = 35degC) (copy at 09B6) */
#define EE_TEMPMID_GET() \
    (int8_t)((ee0x5b0 & 0xff00u) >> 8U)
/** CALIBCRC : 8bit EEPROM calibration area CRC ( sum with carry ) */
#define EE_CALIBCRC_GET() \
    (uint8_t)((ee0x5b0 & 0x00ffu) >> 0U)
/** APP_TRIM1 : reserved[15:0] */
#define EE_APP_TRIM1_GET() \
    (uint16_t)((ee0x5b2 & 0xffffu) >> 0U)
/** O_VSMF : Offset of VSMF/26 input at mid temperature */
#define EE_O_VSMF_GET() \
    (uint16_t)((ee0x5b2 & 0x0fffu) >> 0U)
/** APP_TRIM2 : OTempCal_EE[15:0] */
#define EE_APP_TRIM2_GET() \
    (uint16_t)((ee0x5b4 & 0xffffu) >> 0U)
/** OTEMPCAL : Temperature Sensor Offset , 16bit unsigned */
#define EE_OTEMPCAL_GET() \
    (uint16_t)((ee0x5b4 & 0xffffu) >> 0U)
/** APP_TRIM3 : {CALIB_VERSION[7:0], TempMid[7:0]} */
#define EE_APP_TRIM3_GET() \
    (uint16_t)((ee0x5b6 & 0xffffu) >> 0U)
/** CALIB_VERSION : Calibration data version */
#define EE_CALIB_VERSION_GET() \
    (uint8_t)((ee0x5b6 & 0xff00u) >> 8U)
/** TEMPMID_CP : Middle Temperature used in production (mostly probing1 = 35degC) (copy at 09B1) */
#define EE_TEMPMID_CP_GET() \
    (int8_t)((ee0x5b6 & 0x00ffu) >> 0U)
/** APP_TRIM4 : {GainTempHighCal_EE[7:0], GainTempLowCal_EE[7:0]} */
#define EE_APP_TRIM4_GET() \
    (uint16_t)((ee0x5b8 & 0xffffu) >> 0U)
/** GAINTEMPHIGHCAL : Temp sensor calibration, Gain for High Temp range */
#define EE_GAINTEMPHIGHCAL_GET() \
    (uint8_t)((ee0x5b8 & 0xff00u) >> 8U)
/** GAINTEMPLOWCAL : Temp sensor calibration, Gain for Low Temp range */
#define EE_GAINTEMPLOWCAL_GET() \
    (uint8_t)((ee0x5b8 & 0x00ffu) >> 0U)
/** APP_TRIM5 : {reserved[2:0],LINAA_DIV_EXT[4:0], OADCCal_EE[7:0]} */
#define EE_APP_TRIM5_GET() \
    (uint16_t)((ee0x5ba & 0xffffu) >> 0U)
/** LINAA_DIV_EXT : extended 5bit LINAA_DIV control for CMR adjustment */
#define EE_LINAA_DIV_EXT_GET() \
    (uint8_t)((ee0x5ba & 0x1f00u) >> 8U)
/** OADCCAL : ADC reference (2.5V) offset [8bit signed] */
#define EE_OADCCAL_GET() \
    (int8_t)((ee0x5ba & 0x00ffu) >> 0U)
/** APP_TRIM6 : {GainADCHighCal_EE[7:0], GainADCLowCal_EE[7:0]} */
#define EE_APP_TRIM6_GET() \
    (uint16_t)((ee0x5bc & 0xffffu) >> 0U)
/** GAINADCHIGHCAL : ADC reference (2.5V) gain for high temp range  [8bit signed] */
#define EE_GAINADCHIGHCAL_GET() \
    (int8_t)((ee0x5bc & 0xff00u) >> 8U)
/** GAINADCLOWCAL : ADC reference (2.5V) gain for low temp range  [8bit signed] */
#define EE_GAINADCLOWCAL_GET() \
    (int8_t)((ee0x5bc & 0x00ffu) >> 0U)
/** O_VBOOST_64_H : Offset of input VBOOST/64 at mid temp */
#define EE_O_VBOOST_64_H_GET() \
    (uint8_t)((ee0x5bc & 0xff00u) >> 8U)
/** APP_TRIM7 : {SClock24HighCal _EE[7:0], SClock24LowCal _EE[7:0]} */
#define EE_APP_TRIM7_GET() \
    (uint16_t)((ee0x5be & 0xffffu) >> 0U)
/** SCLOCK24HIGHCAL : CPU clock (24MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK24HIGHCAL_GET() \
    (int8_t)((ee0x5be & 0xff00u) >> 8U)
/** SCLOCK24LOWCAL : CPU clock (24MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK24LOWCAL_GET() \
    (int8_t)((ee0x5be & 0x00ffu) >> 0U)
/** GAINHI_CURR_G20 : Gain-change of current sensor input * 20 over high temperature range */
#define EE_GAINHI_CURR_G20_GET() \
    (int8_t)((ee0x5be & 0xff00u) >> 8U)
/** GAINLO_CURR_G20 : Gain-change of current sensor input * 20 over low temperature range */
#define EE_GAINLO_CURR_G20_GET() \
    (int8_t)((ee0x5be & 0x00ffu) >> 0U)
/** APP_TRIM8 : {SClock28LowCal _EE[7:0], OClock24Cal _EE[7:0]} */
#define EE_APP_TRIM8_GET() \
    (uint16_t)((ee0x5c0 & 0xffffu) >> 0U)
/** SCLOCK28LOWCAL : CPU clock (28MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK28LOWCAL_GET() \
    (int8_t)((ee0x5c0 & 0xff00u) >> 8U)
/** OCLOCK24CAL : CPU clock (24MHz)  Offset [8bit signed] */
#define EE_OCLOCK24CAL_GET() \
    (int8_t)((ee0x5c0 & 0x00ffu) >> 0U)
/** O_CURR_G20_L : Offset of current sensor input * 20 at mid temp */
#define EE_O_CURR_G20_L_GET() \
    (uint8_t)((ee0x5c0 & 0xf000u) >> 12U)
/** GAIN_CURR_G20 : Gain of current sensor input * 20 at mid temp */
#define EE_GAIN_CURR_G20_GET() \
    (uint16_t)((ee0x5c0 & 0x0fffu) >> 0U)
/** APP_TRIM9 : {OClock28Cal _EE[7:0], SClock28HighCal _EE[7:0]} */
#define EE_APP_TRIM9_GET() \
    (uint16_t)((ee0x5c2 & 0xffffu) >> 0U)
/** OCLOCK28CAL : CPU clock (28MHz)  Offset [8bit signed] */
#define EE_OCLOCK28CAL_GET() \
    (int8_t)((ee0x5c2 & 0xff00u) >> 8U)
/** SCLOCK28HIGHCAL : CPU clock (28MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK28HIGHCAL_GET() \
    (int8_t)((ee0x5c2 & 0x00ffu) >> 0U)
/** O_CURR_G20_H : Offset of current sensor input * 20 at mid temp */
#define EE_O_CURR_G20_H_GET() \
    (uint8_t)((ee0x5c2 & 0x00ffu) >> 0U)
/** APP_TRIM10 : {SClock32HighCal _EE[7:0], SClock32LowCal _EE[7:0]} */
#define EE_APP_TRIM10_GET() \
    (uint16_t)((ee0x5c4 & 0xffffu) >> 0U)
/** SCLOCK32HIGHCAL : CPU clock (30MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK32HIGHCAL_GET() \
    (int8_t)((ee0x5c4 & 0xff00u) >> 8U)
/** SCLOCK32LOWCAL : CPU clock (30MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK32LOWCAL_GET() \
    (int8_t)((ee0x5c4 & 0x00ffu) >> 0U)
/** APP_TRIM11 : {O10kHzCal_EE[7:0], OClock32Cal _EE[7:0]} */
#define EE_APP_TRIM11_GET() \
    (uint16_t)((ee0x5c6 & 0xffffu) >> 0U)
/** O10KHZCAL : Wake up Clock Offset [8bit signed] */
#define EE_O10KHZCAL_GET() \
    (int8_t)((ee0x5c6 & 0xff00u) >> 8U)
/** OCLOCK32CAL : CPU clock (30MHz)  Offset [8bit signed] */
#define EE_OCLOCK32CAL_GET() \
    (int8_t)((ee0x5c6 & 0x00ffu) >> 0U)
/** APP_TRIM12 : Rshunt from the LIN autoconfig block */
#define EE_APP_TRIM12_GET() \
    (uint16_t)((ee0x5c8 & 0xffffu) >> 0U)
/** LINAA_INT_SHUNT : Rshunt from the LIN autoconfig block */
#define EE_LINAA_INT_SHUNT_GET() \
    (uint16_t)((ee0x5c8 & 0xffffu) >> 0U)
/** GAINHI_PHASE_52 : Gain-change of phase input HVI/52 over high temperature range */
#define EE_GAINHI_PHASE_52_GET() \
    (int8_t)((ee0x5c8 & 0xff00u) >> 8U)
/** GAINLO_PHASE_52 : Gain-change of phase input HVI/52 over low temperature range */
#define EE_GAINLO_PHASE_52_GET() \
    (int8_t)((ee0x5c8 & 0x00ffu) >> 0U)
/** APP_TRIM13 : reserved[15:0] */
#define EE_APP_TRIM13_GET() \
    (uint16_t)((ee0x5ca & 0xffffu) >> 0U)
/** O_PHASE_52_L : Offset of phase input HVI/52 at mid temperature */
#define EE_O_PHASE_52_L_GET() \
    (uint8_t)((ee0x5ca & 0xf000u) >> 12U)
/** GAIN_PHASE_52 : Gain of phase input HVI/52 at mid temperature */
#define EE_GAIN_PHASE_52_GET() \
    (uint16_t)((ee0x5ca & 0x0fffu) >> 0U)
/** APP_TRIM14 : LINAA_SDMCM_EE[15:0] */
#define EE_APP_TRIM14_GET() \
    (uint16_t)((ee0x5cc & 0xffffu) >> 0U)
/** LINAA_SDMCM : LINAA - differential current measurement sensitivity to common mode voltage step */
#define EE_LINAA_SDMCM_GET() \
    (int16_t)((ee0x5cc & 0xffffu) >> 0U)
/** GAINLO_VSMF_52 : Gain-change of VSMF/52 input over low temperature range */
#define EE_GAINLO_VSMF_52_GET() \
    (int8_t)((ee0x5cc & 0xff00u) >> 8U)
/** O_PHASE_52_H : Offset of phase input HVI/52 at mid temperature */
#define EE_O_PHASE_52_H_GET() \
    (uint8_t)((ee0x5cc & 0x00ffu) >> 0U)
/** APP_TRIM15 : LINAA_GainDMCal_EE [15:0] */
#define EE_APP_TRIM15_GET() \
    (uint16_t)((ee0x5ce & 0xffffu) >> 0U)
/** LINAA_GAINDMCAL : LINAA - differential current measurement sensitivity to  current */
#define EE_LINAA_GAINDMCAL_GET() \
    (int16_t)((ee0x5ce & 0xffffu) >> 0U)
/** GAIN_VSMF_52_L : Gain of VSMF/52 input at mid temperature */
#define EE_GAIN_VSMF_52_L_GET() \
    (uint8_t)((ee0x5ce & 0xff00u) >> 8U)
/** GAINHI_VSMF_52 : Gain-change of VSMF/52 input over high temperature range */
#define EE_GAINHI_VSMF_52_GET() \
    (int8_t)((ee0x5ce & 0x00ffu) >> 0U)
/** APP_TRIM16 : {IAA_Trim205mA[7:0], IAA_Trim045mA[7:0]} */
#define EE_APP_TRIM16_GET() \
    (uint16_t)((ee0x5d0 & 0xffffu) >> 0U)
/** LINAA_LCD_SEL_205 : IAA_Trim205mA[7:6]: current selection for low side diagnosis current source for 205mA */
#define EE_LINAA_LCD_SEL_205_GET() \
    (uint8_t)((ee0x5d0 & 0xc000u) >> 14U)
/** LINAA_TRIM_LCD_205 : IAA_Trim205mA[5:0]:  trimming for low side diagnosis current source for 205mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_205_GET() \
    (int8_t)((ee0x5d0 & 0x3f00u) >> 8U)
/** LINAA_LCD_SEL_112 : IAA_Trim045mA[7:6]: current selection for low side diagnosis current source for 0.45mA */
#define EE_LINAA_LCD_SEL_112_GET() \
    (uint8_t)((ee0x5d0 & 0x00c0u) >> 6U)
/** LINAA_TRIM_LCD_112 : IAA_Trim045mA[5:0]:  trimming for low side diagnosis current source for 0.45mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_112_GET() \
    (int8_t)((ee0x5d0 & 0x003fu) >> 0U)
/** LINAA_LCD_SEL_045 : IAA_Trim045mA[7:6]: current selection for low side diagnosis current source for 0.45mA */
#define EE_LINAA_LCD_SEL_045_GET() \
    (uint8_t)((ee0x5d0 & 0x00c0u) >> 6U)
/** LINAA_TRIM_LCD_045 : IAA_Trim045mA[5:0]:  trimming for low side diagnosis current source for 0.45mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_045_GET() \
    (int8_t)((ee0x5d0 & 0x003fu) >> 0U)
/** O_VSMF_52 : Offset of VSMF/52 input at mid temperature */
#define EE_O_VSMF_52_GET() \
    (uint16_t)((ee0x5d0 & 0xfff0u) >> 4U)
/** GAIN_VSMF_52_H : Gain of VSMF/52 input at mid temperature */
#define EE_GAIN_VSMF_52_H_GET() \
    (uint8_t)((ee0x5d0 & 0x000fu) >> 0U)
/** APP_TRIM17 : {LIN_AA_DIV[3:0], LINN_AA_GAIN[3:0], IAA_Trim240mA[7:0]} */
#define EE_APP_TRIM17_GET() \
    (uint16_t)((ee0x5d2 & 0xffffu) >> 0U)
/** LINAA_DIV : Common mode suppression adjustements bits, copy to PORT_LINAA1 */
#define EE_LINAA_DIV_GET() \
    (uint8_t)((ee0x5d2 & 0xf000u) >> 12U)
/** LINAA_GAIN : Gain control bits of the variable gain amp, , copy to PORT_LINAA1 */
#define EE_LINAA_GAIN_GET() \
    (uint8_t)((ee0x5d2 & 0x0f00u) >> 8U)
/** LINAA_LCD_SEL_240 : IAA_Trim240mA[7:6]: current selection for low side diagnosis current source for 2.4mA */
#define EE_LINAA_LCD_SEL_240_GET() \
    (uint8_t)((ee0x5d2 & 0x00c0u) >> 6U)
/** LINAA_TRIM_LCD_240 : IAA_Trim240mA[5:0]:  trimming for low side diagnosis current source for 2.4mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_240_GET() \
    (int8_t)((ee0x5d2 & 0x003fu) >> 0U)
/** APP_TRIM18 : application specific calibration information */
#define EE_APP_TRIM18_GET() \
    (uint16_t)((ee0x5d4 & 0xffffu) >> 0U)
/** GAINHI_VSMF : Gain-change of VSMF/26 input at high temperature */
#define EE_GAINHI_VSMF_GET() \
    (int8_t)((ee0x5d4 & 0xff00u) >> 8U)
/** GAINLO_VSMF : Gain-change of VSMF/26 input at low temperature */
#define EE_GAINLO_VSMF_GET() \
    (int8_t)((ee0x5d4 & 0x00ffu) >> 0U)
/** APP_TRIM19 : application specific calibration information */
#define EE_APP_TRIM19_GET() \
    (uint16_t)((ee0x5d6 & 0xffffu) >> 0U)
/** GAIN_VSMF : Gain of VSMF/26 input at mid temperature */
#define EE_GAIN_VSMF_GET() \
    (uint16_t)((ee0x5d6 & 0x0fffu) >> 0U)
/** APP_TRIM20 : application specific calibration information */
#define EE_APP_TRIM20_GET() \
    (uint16_t)((ee0x5d8 & 0xffffu) >> 0U)
/** MTEMPLOW : Raw ADC measurement of temperature sensor at Low Test Temperature */
#define EE_MTEMPLOW_GET() \
    (uint16_t)((ee0x5d8 & 0xffffu) >> 0U)
/** APP_TRIM21 : application specific calibration information */
#define EE_APP_TRIM21_GET() \
    (uint16_t)((ee0x5da & 0xffffu) >> 0U)
/** MTEMPHIGH : Raw ADC measurement of temperature sensor at High Test Temperature */
#define EE_MTEMPHIGH_GET() \
    (uint16_t)((ee0x5da & 0xffffu) >> 0U)
/** APP_TRIM22 : application specific calibration information */
#define EE_APP_TRIM22_GET() \
    (uint16_t)((ee0x5dc & 0xffffu) >> 0U)
/** GAINHI_CURR : Gain-change of current sensor input * 10 over high temperature range */
#define EE_GAINHI_CURR_GET() \
    (int8_t)((ee0x5dc & 0xff00u) >> 8U)
/** GAINLO_CURR : Gain-change of current sensor input * 10 over low temperature range */
#define EE_GAINLO_CURR_GET() \
    (int8_t)((ee0x5dc & 0x00ffu) >> 0U)
/** APP_TRIM23 : application specific calibration information */
#define EE_APP_TRIM23_GET() \
    (uint16_t)((ee0x5de & 0xffffu) >> 0U)
/** O_CURR_L : Offset of current sensor input * 10 at mid temp */
#define EE_O_CURR_L_GET() \
    (uint8_t)((ee0x5de & 0xf000u) >> 12U)
/** GAIN_CURR : Gain of current sensor input * 10 at mid temp */
#define EE_GAIN_CURR_GET() \
    (uint16_t)((ee0x5de & 0x0fffu) >> 0U)
/** APP_TRIM24 : application specific calibration information */
#define EE_APP_TRIM24_GET() \
    (uint16_t)((ee0x5e0 & 0xffffu) >> 0U)
/** GAINLO_VBOOST : Gain-change of input VBOOST/32 over low temperature range */
#define EE_GAINLO_VBOOST_GET() \
    (int8_t)((ee0x5e0 & 0xff00u) >> 8U)
/** O_CURR_H : Offset of current sensor input * 10 at mid temp */
#define EE_O_CURR_H_GET() \
    (uint8_t)((ee0x5e0 & 0x00ffu) >> 0U)
/** APP_TRIM25 : application specific calibration information */
#define EE_APP_TRIM25_GET() \
    (uint16_t)((ee0x5e2 & 0xffffu) >> 0U)
/** GAIN_VBOOST_L : Gain of input VBOOST/32 at mid temp */
#define EE_GAIN_VBOOST_L_GET() \
    (uint8_t)((ee0x5e2 & 0xff00u) >> 8U)
/** GAINHI_VBOOST : Gain-change of input VBOOST/32 over high temperature range */
#define EE_GAINHI_VBOOST_GET() \
    (int8_t)((ee0x5e2 & 0x00ffu) >> 0U)
/** APP_TRIM26 : application specific calibration information */
#define EE_APP_TRIM26_GET() \
    (uint16_t)((ee0x5e4 & 0xffffu) >> 0U)
/** O_VBOOST : Offset of input VBOOST/32 at mid temp */
#define EE_O_VBOOST_GET() \
    (uint16_t)((ee0x5e4 & 0xfff0u) >> 4U)
/** GAIN_VBOOST_H : Gain of input VBOOST/32 at mid temp */
#define EE_GAIN_VBOOST_H_GET() \
    (uint8_t)((ee0x5e4 & 0x000fu) >> 0U)
/** APP_TRIM27 : application specific calibration information */
#define EE_APP_TRIM27_GET() \
    (uint16_t)((ee0x5e6 & 0xffffu) >> 0U)
/** GAINHI_HVI : Gain-change of High-voltage input over high temperature range */
#define EE_GAINHI_HVI_GET() \
    (int8_t)((ee0x5e6 & 0xff00u) >> 8U)
/** GAINLO_HVI : Gain-change of High-voltage input over low temperature range */
#define EE_GAINLO_HVI_GET() \
    (int8_t)((ee0x5e6 & 0x00ffu) >> 0U)
/** APP_TRIM28 : application specific calibration information */
#define EE_APP_TRIM28_GET() \
    (uint16_t)((ee0x5e8 & 0xffffu) >> 0U)
/** O_HVI_L : Gain of High-voltage input HVI/26 at mid temp */
#define EE_O_HVI_L_GET() \
    (uint8_t)((ee0x5e8 & 0xf000u) >> 12U)
/** GAIN_HVI : Gain of High-voltage input HVI/26 at mid temp */
#define EE_GAIN_HVI_GET() \
    (uint16_t)((ee0x5e8 & 0x0fffu) >> 0U)
/** APP_TRIM29 : application specific calibration information */
#define EE_APP_TRIM29_GET() \
    (uint16_t)((ee0x5ea & 0xffffu) >> 0U)
/** GAINLO_LVI : Gain-change of Low-voltage input over low temperature range */
#define EE_GAINLO_LVI_GET() \
    (int8_t)((ee0x5ea & 0xff00u) >> 8U)
/** O_HVI_H : Offset of High-voltage input HVI/26 at mid temp */
#define EE_O_HVI_H_GET() \
    (uint8_t)((ee0x5ea & 0x00ffu) >> 0U)
/** APP_TRIM30 : application specific calibration information */
#define EE_APP_TRIM30_GET() \
    (uint16_t)((ee0x5ec & 0xffffu) >> 0U)
/** GAIN_LVI_L : Gain of Low-voltage input LVI/2.5 at mid temp */
#define EE_GAIN_LVI_L_GET() \
    (uint8_t)((ee0x5ec & 0xff00u) >> 8U)
/** GAINHI_LVI : Gain-change of Low-voltage input over high temperature range */
#define EE_GAINHI_LVI_GET() \
    (int8_t)((ee0x5ec & 0x00ffu) >> 0U)
/** APP_TRIM31 : application specific calibration information */
#define EE_APP_TRIM31_GET() \
    (uint16_t)((ee0x5ee & 0xffffu) >> 0U)
/** O_LVI : Offset of Low-voltage input LVI/2.5 at mid temp */
#define EE_O_LVI_GET() \
    (uint16_t)((ee0x5ee & 0xfff0u) >> 4U)
/** GAIN_LVI_H : Gain of Low-voltage input LVI/2.5 at mid temp */
#define EE_GAIN_LVI_H_GET() \
    (uint8_t)((ee0x5ee & 0x000fu) >> 0U)
/** APP_TRIM32 : application specific calibration information */
#define EE_APP_TRIM32_GET() \
    (uint16_t)((ee0x5f0 & 0xffffu) >> 0U)
/** LOCK_TRIM0 : lock bit */
#define EE_LOCK_TRIM0_GET() \
    (uint8_t)((ee0x5f0 & 0x8000u) >> 15U)
/** ADC_BLOCK_BYPASSBUF : bypass ADC input buffer */
#define EE_ADC_BLOCK_BYPASSBUF_GET() \
    (uint8_t)((ee0x5f0 & 0x2000u) >> 13U)
/** ADC_BLOCK_INTERCHOP : enable chopping of internal ADC reference */
#define EE_ADC_BLOCK_INTERCHOP_GET() \
    (uint8_t)((ee0x5f0 & 0x1000u) >> 12U)
/** ADC_BLOCK_LATCHCTRL : comparator latch definition */
#define EE_ADC_BLOCK_LATCHCTRL_GET() \
    (uint8_t)((ee0x5f0 & 0x0800u) >> 11U)
/** ADC_INTREF_TRM : reference voltage selection, 3=>Vintref=1.51V, this is the default for 8134x */
#define EE_ADC_INTREF_TRM_GET() \
    (uint8_t)((ee0x5f0 & 0x0700u) >> 8U)
/** TRIM_SDAFILT_IO : I2C SDA filtertrimming */
#define EE_TRIM_SDAFILT_IO_GET() \
    (uint8_t)((ee0x5f0 & 0x00c0u) >> 6U)
/** TRIM_OTD : Overtemperature detection trimming */
#define EE_TRIM_OTD_GET() \
    (uint8_t)((ee0x5f0 & 0x003fu) >> 0U)
/** APP_TRIM33 : application specific calibration information */
#define EE_APP_TRIM33_GET() \
    (uint16_t)((ee0x5f2 & 0xffffu) >> 0U)
/** LOCK_TRIM1 : lock bit */
#define EE_LOCK_TRIM1_GET() \
    (uint8_t)((ee0x5f2 & 0x8000u) >> 15U)
/** TR_IO_OCD : trimming overcurrent IO3/4 */
#define EE_TR_IO_OCD_GET() \
    (uint8_t)((ee0x5f2 & 0x2000u) >> 13U)
/** TR_OCVDDA : trimming overcurrent VDDA */
#define EE_TR_OCVDDA_GET() \
    (uint8_t)((ee0x5f2 & 0x1000u) >> 12U)
/** CNT_IILD : internal dead time */
#define EE_CNT_IILD_GET() \
    (uint8_t)((ee0x5f2 & 0x0f00u) >> 8U)
/** TR_CP : trimming of the charge pump voltage */
#define EE_TR_CP_GET() \
    (int8_t)((ee0x5f2 & 0x00f0u) >> 4U)
/** TR_RCO50K : trimming of the 50k charge pump clock */
#define EE_TR_RCO50K_GET() \
    (int8_t)((ee0x5f2 & 0x000fu) >> 0U)
/** APP_TRIM34 : application specific calibration information */
#define EE_APP_TRIM34_GET() \
    (uint16_t)((ee0x5f4 & 0xffffu) >> 0U)
/** OOCS : offset of the overcurrent DAC */
#define EE_OOCS_GET() \
    (int8_t)((ee0x5f4 & 0xff00u) >> 8U)
/** GOCS : gain of the overcurrent DAC */
#define EE_GOCS_GET() \
    (uint8_t)((ee0x5f4 & 0x00ffu) >> 0U)
/** APP_TRIM35 : application specific calibration information */
#define EE_APP_TRIM35_GET() \
    (uint16_t)((ee0x5f6 & 0xffffu) >> 0U)
/** USER_EE : word for user purposes */
#define EE_USER_EE_GET() \
    (uint16_t)((ee0x5f6 & 0xffffu) >> 0U)
/** APP_TRIM36 : speed7 reserved for additional speed settings */
#define EE_APP_TRIM36_GET() \
    (uint16_t)((ee0x5f8 & 0xffffu) >> 0U)
/** SPEED7 : speed7 reserved for additional speed settings */
#define EE_SPEED7_GET() \
    (uint16_t)((ee0x5f8 & 0xffffu) >> 0U)
/** GAINHI_VBOOST_64 : Gain-change of input VBOOST/64 over high temperature range */
#define EE_GAINHI_VBOOST_64_GET() \
    (int8_t)((ee0x5f8 & 0xff00u) >> 8U)
/** GAINLO_VBOOST_64 : Gain-change of input VBOOST/64 over low temperature range */
#define EE_GAINLO_VBOOST_64_GET() \
    (int8_t)((ee0x5f8 & 0x00ffu) >> 0U)
/** APP_TRIM37 : speed6 reserved for additional speed settings */
#define EE_APP_TRIM37_GET() \
    (uint16_t)((ee0x5fa & 0xffffu) >> 0U)
/** SPEED6 : speed6 reserved for additional speed settings */
#define EE_SPEED6_GET() \
    (uint16_t)((ee0x5fa & 0xffffu) >> 0U)
/** O_VBOOST_64_L : Offset of input VBOOST/64 at mid temp */
#define EE_O_VBOOST_64_L_GET() \
    (uint8_t)((ee0x5fa & 0xf000u) >> 12U)
/** GAIN_VBOOST_64 : Gain of input VBOOST/64 at mid temp */
#define EE_GAIN_VBOOST_64_GET() \
    (uint16_t)((ee0x5fa & 0x0fffu) >> 0U)
/** APP_TRIM38 : speed5 reserved for additional speed settings */
#define EE_APP_TRIM38_GET() \
    (uint16_t)((ee0x5fc & 0xffffu) >> 0U)
/** SPEED5 : speed5 reserved for additional speed settings */
#define EE_SPEED5_GET() \
    (uint16_t)((ee0x5fc & 0xffffu) >> 0U)
/** APP_TRIM39 : speed4 setting for 32MHz/16MHz with 2 flash wait states */
#define EE_APP_TRIM39_GET() \
    (uint16_t)((ee0x5fe & 0xffffu) >> 0U)
/** SPEED4 : speed4 setting for 32MHz/16MHz with 2 flash wait states */
#define EE_SPEED4_GET() \
    (uint16_t)((ee0x5fe & 0xffffu) >> 0U)
/** MELEXIS_TRIM_CRC : Melexis Trimming - CRC location */
#define EE_MELEXIS_TRIM_CRC_GET() \
    (uint16_t)((ee0x600 & 0xffffu) >> 0U)
/** ROM_CONFIGURATION : ROM_CONFIGURATION byte used by ROM code, function is project specific */
#define EE_ROM_CONFIGURATION_GET() \
    (uint8_t)((ee0x600 & 0xff00u) >> 8U)
/** CRC_CS : CRC checksum of config sector */
#define EE_CRC_CS_GET() \
    (uint8_t)((ee0x600 & 0x00ffu) >> 0U)
/** IGNORE_RSTAT_FOR_WARM_BOOT : define if RSTAT bit shall be considered for application startup */
#define EE_IGNORE_RSTAT_FOR_WARM_BOOT_GET() \
    (uint8_t)((ee0x600 & 0x0800u) >> 11U)
/** FASTLIN_5V : define if fast 5V receiver is used for FASTLIN */
#define EE_FASTLIN_5V_GET() \
    (uint8_t)((ee0x600 & 0x0400u) >> 10U)
/** PPM_5V : define if fast 5V receiver is used for PPM */
#define EE_PPM_5V_GET() \
    (uint8_t)((ee0x600 & 0x0200u) >> 9U)
/** DISTERM : define if LIN termination is connected */
#define EE_DISTERM_GET() \
    (uint8_t)((ee0x600 & 0x0100u) >> 8U)
/** MS_TRIM0 : trim_bg_bias (bandgap, bias) */
#define EE_MS_TRIM0_GET() \
    (uint16_t)((ee0x602 & 0xffffu) >> 0U)
/** LOCK_MS_TRIM0 : lock bit of trim port */
#define EE_LOCK_MS_TRIM0_GET() \
    (uint8_t)((ee0x602 & 0x8000u) >> 15U)
/** MS_TR_BIAS : trim bias source */
#define EE_MS_TR_BIAS_GET() \
    (int8_t)((ee0x602 & 0x3f00u) >> 8U)
/** MS_TR_BGD : trim digital bandgap */
#define EE_MS_TR_BGD_GET() \
    (int8_t)((ee0x602 & 0x00f0u) >> 4U)
/** MS_TR_BGA : trim analog bandgap */
#define EE_MS_TR_BGA_GET() \
    (int8_t)((ee0x602 & 0x000fu) >> 0U)
/** MS_TRIM1 : trim_vdd (tr_sup, vddd, vdda) */
#define EE_MS_TRIM1_GET() \
    (uint16_t)((ee0x604 & 0xffffu) >> 0U)
/** LOCK_MS_TRIM1 : lock bit of trim port */
#define EE_LOCK_MS_TRIM1_GET() \
    (uint8_t)((ee0x604 & 0x8000u) >> 15U)
/** MS_TR_SUP : trim support bits, if used application shall copy them into the port */
#define EE_MS_TR_SUP_GET() \
    (uint8_t)((ee0x604 & 0x3fc0u) >> 6U)
/** MS_TR_VDDD : digital supply trimming */
#define EE_MS_TR_VDDD_GET() \
    (int8_t)((ee0x604 & 0x0038u) >> 3U)
/** MS_TR_VDDA : analog supply trimming */
#define EE_MS_TR_VDDA_GET() \
    (int8_t)((ee0x604 & 0x0007u) >> 0U)
/** MS_TRIM2 : trim_rco1m_lin (1MHz RCO, LIN) */
#define EE_MS_TRIM2_GET() \
    (uint16_t)((ee0x606 & 0xffffu) >> 0U)
/** LOCK_MS_TRIM2 : lock bit of trim port */
#define EE_LOCK_MS_TRIM2_GET() \
    (uint8_t)((ee0x606 & 0x8000u) >> 15U)
/** MS_TR_LIN_SLVTERM : LIN slave termination trimming */
#define EE_MS_TR_LIN_SLVTERM_GET() \
    (int8_t)((ee0x606 & 0x3800u) >> 11U)
/** MS_TR_LIN_SLEWRATE : LIN slewrate trimming */
#define EE_MS_TR_LIN_SLEWRATE_GET() \
    (uint8_t)((ee0x606 & 0x0700u) >> 8U)
/** MS_TR_RCO1M : RCO 1MHz trimming */
#define EE_MS_TR_RCO1M_GET() \
    (uint8_t)((ee0x606 & 0x00ffu) >> 0U)
/** MS_TRIM3 : SAR ADC: adc_sar_tr_adcref1 ((ADC refs 1+2); ECADC: Calibration factor CORR[15:0] */
#define EE_MS_TRIM3_GET() \
    (uint16_t)((ee0x608 & 0xffffu) >> 0U)
/** TR_ADCREF2 : Option SAR ADC: reference trimming for xxx V */
#define EE_TR_ADCREF2_GET() \
    (uint8_t)((ee0x608 & 0x3f80u) >> 7U)
/** TR_ADCREF1 : Option SAR ADC:  reference trimming for xxx V, */
#define EE_TR_ADCREF1_GET() \
    (uint8_t)((ee0x608 & 0x007fu) >> 0U)
/** CORR_15_0 : Option ECADC: Calibration bits CORR[15:0] */
#define EE_CORR_15_0_GET() \
    (uint16_t)((ee0x608 & 0xffffu) >> 0U)
/** MS_TRIM4 : SAR ADC: adc_sar_tr_adcref3 (ADC ref 3); ECADC: Calibration factor CORR[31:16] */
#define EE_MS_TRIM4_GET() \
    (uint16_t)((ee0x60a & 0xffffu) >> 0U)
/** TR_ADCREF3 : Option SAR ADC: reference trimming for xxx V */
#define EE_TR_ADCREF3_GET() \
    (uint8_t)((ee0x60a & 0x007fu) >> 0U)
/** CORR_31_16 : Option ECADC: Calibration bits CORR[31:16] */
#define EE_CORR_31_16_GET() \
    (uint16_t)((ee0x60a & 0xffffu) >> 0U)
/** MS_TRIM5 : SAR ADC: trim_vdd_ext (second regulator vddio) ; ECADC: Calibration factor CORR[46:32] */
#define EE_MS_TRIM5_GET() \
    (uint16_t)((ee0x60c & 0xffffu) >> 0U)
/** LOCK_MS_TRIM5 : Option SAR ADC - lock bit of trim port, not used for ECADC */
#define EE_LOCK_MS_TRIM5_GET() \
    (uint8_t)((ee0x60c & 0x8000u) >> 15U)
/** MS_TR_VDDIO : Option SAR ADC - trimming for second regulator 5V */
#define EE_MS_TR_VDDIO_GET() \
    (uint8_t)((ee0x60c & 0x0007u) >> 0U)
/** CORR_46_32 : Option ECADC: Calibration bits CORR[46:32] */
#define EE_CORR_46_32_GET() \
    (uint16_t)((ee0x60c & 0x7fffu) >> 0U)
/** MS_TRIM6 : speed1 setting for 24/12 MHz */
#define EE_MS_TRIM6_GET() \
    (uint16_t)((ee0x60e & 0xffffu) >> 0U)
/** EE_AC_SL_WAIT_OPTION_SPEED1 : SPEED1 - RCO trimming, 24/12MHz, ac_sl option for ee wait states */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED1_GET() \
    (uint8_t)((ee0x60e & 0x8000u) >> 15U)
/** FL_AC_SL_WAIT_OPTION_SPEED1 : ac_sl option for flash wait states */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED1_GET() \
    (uint8_t)((ee0x60e & 0x4000u) >> 14U)
/** FL_WAIT_STATES_P_SPEED1 : encoded flash wait states, (values {0,1,2,3} map to FL_WAIT_STATES=FL_AC_ SL_OPTION? {1,2,3,4} : {1,1,2,3} ) */
#define EE_FL_WAIT_STATES_P_SPEED1_GET() \
    (uint8_t)((ee0x60e & 0x3000u) >> 12U)
/** EE_WAIT_STATES_P_SPEED1 : encoded ee wait states, (values {0,1,2,3} map to EE_WAIT_STATES=EE_AC_ SL_OPTION? {4,5,6,7} : {3,4,5,6} ) */
#define EE_EE_WAIT_STATES_P_SPEED1_GET() \
    (uint8_t)((ee0x60e & 0x0c00u) >> 10U)
/** TR_RCO32M_IN_SPEED1 : RC oscillator trim code */
#define EE_TR_RCO32M_IN_SPEED1_GET() \
    (uint16_t)((ee0x60e & 0x03ffu) >> 0U)
/** MS_TRIM7 : speed2 setting for 28/14 MHz */
#define EE_MS_TRIM7_GET() \
    (uint16_t)((ee0x610 & 0xffffu) >> 0U)
/** EE_AC_SL_WAIT_OPTION_SPEED2 : SPEED2 - RCO trimming, 28/14MHz */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED2_GET() \
    (uint8_t)((ee0x610 & 0x8000u) >> 15U)
/** FL_AC_SL_WAIT_OPTION_SPEED2 :  */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED2_GET() \
    (uint8_t)((ee0x610 & 0x4000u) >> 14U)
/** FL_WAIT_STATES_P_SPEED2 :  */
#define EE_FL_WAIT_STATES_P_SPEED2_GET() \
    (uint8_t)((ee0x610 & 0x3000u) >> 12U)
/** EE_WAIT_STATES_P_SPEED2 :  */
#define EE_EE_WAIT_STATES_P_SPEED2_GET() \
    (uint8_t)((ee0x610 & 0x0c00u) >> 10U)
/** TR_RCO32M_IN_SPEED2 :  */
#define EE_TR_RCO32M_IN_SPEED2_GET() \
    (uint16_t)((ee0x610 & 0x03ffu) >> 0U)
/** MS_TRIM8 : speed3 setting for 32/16 MHz */
#define EE_MS_TRIM8_GET() \
    (uint16_t)((ee0x612 & 0xffffu) >> 0U)
/** EE_AC_SL_WAIT_OPTION_SPEED3 : SPEED3 - RCO trimming, 32/16MHz */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED3_GET() \
    (uint8_t)((ee0x612 & 0x8000u) >> 15U)
/** FL_AC_SL_WAIT_OPTION_SPEED3 :  */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED3_GET() \
    (uint8_t)((ee0x612 & 0x4000u) >> 14U)
/** FL_WAIT_STATES_P_SPEED3 :  */
#define EE_FL_WAIT_STATES_P_SPEED3_GET() \
    (uint8_t)((ee0x612 & 0x3000u) >> 12U)
/** EE_WAIT_STATES_P_SPEED3 :  */
#define EE_EE_WAIT_STATES_P_SPEED3_GET() \
    (uint8_t)((ee0x612 & 0x0c00u) >> 10U)
/** TR_RCO32M_IN_SPEED3 :  */
#define EE_TR_RCO32M_IN_SPEED3_GET() \
    (uint16_t)((ee0x612 & 0x03ffu) >> 0U)
/** NV_TRIM0 : R2_EE */
#define EE_NV_TRIM0_GET() \
    (uint16_t)((ee0x614 & 0xffffu) >> 0U)
/** R2_EE : R2_EE */
#define EE_R2_EE_GET() \
    (uint16_t)((ee0x614 & 0xffffu) >> 0U)
/** TSENSE : Sense time settings */
#define EE_TSENSE_GET() \
    (uint8_t)((ee0x614 & 0x7000u) >> 12U)
/** TRDY : Ready signal delay settings */
#define EE_TRDY_GET() \
    (uint8_t)((ee0x614 & 0x0c00u) >> 10U)
/** TPRE : Precharge delay settings */
#define EE_TPRE_GET() \
    (uint8_t)((ee0x614 & 0x0300u) >> 8U)
/** EN_VMG : VMG voltage to memory gates */
#define EE_EN_VMG_GET() \
    (uint8_t)((ee0x614 & 0x0080u) >> 7U)
/** EN_VMG_CT : enable VMGM margin voltage at CSA */
#define EE_EN_VMG_CT_GET() \
    (uint8_t)((ee0x614 & 0x0040u) >> 6U)
/** EN_VMG_TT : enable VMGM margin voltage at MSA */
#define EE_EN_VMG_TT_GET() \
    (uint8_t)((ee0x614 & 0x0020u) >> 5U)
/** SW_VMGM_EE : VMG margin voltage (VMGM) */
#define EE_SW_VMGM_EE_GET() \
    (uint8_t)((ee0x614 & 0x001fu) >> 0U)
/** NV_TRIM1 : R1_EE */
#define EE_NV_TRIM1_GET() \
    (uint16_t)((ee0x616 & 0xffffu) >> 0U)
/** R1_EE : R1_EE */
#define EE_R1_EE_GET() \
    (uint16_t)((ee0x616 & 0xffffu) >> 0U)
/** REG_1_RES : register, reserve */
#define EE_REG_1_RES_GET() \
    (uint8_t)((ee0x616 & 0x8000u) >> 15U)
/** CP_CLK_DIV : CP clock divider */
#define EE_CP_CLK_DIV_GET() \
    (uint8_t)((ee0x616 & 0x6000u) >> 13U)
/** EE_CP_SC_FL : disable second CP chain */
#define EE_EE_CP_SC_FL_GET() \
    (uint8_t)((ee0x616 & 0x1000u) >> 12U)
/** SEL_ODD : select odd cells in CS / MA */
#define EE_SEL_ODD_GET() \
    (uint8_t)((ee0x616 & 0x0800u) >> 11U)
/** SEL_EVEN : select even cells in CS / MA */
#define EE_SEL_EVEN_GET() \
    (uint8_t)((ee0x616 & 0x0400u) >> 10U)
/** SEL_CS : select CS */
#define EE_SEL_CS_GET() \
    (uint8_t)((ee0x616 & 0x0200u) >> 9U)
/** SEL_MA : select MA */
#define EE_SEL_MA_GET() \
    (uint8_t)((ee0x616 & 0x0100u) >> 8U)
/** TR_PCP1_W_EE : EEPROM program voltage */
#define EE_TR_PCP1_W_EE_GET() \
    (uint8_t)((ee0x616 & 0x00f0u) >> 4U)
/** TR_PCP1_E_EE : EEPROM erase voltage */
#define EE_TR_PCP1_E_EE_GET() \
    (uint8_t)((ee0x616 & 0x000fu) >> 0U)
/** NV_TRIM2 : R3_FL */
#define EE_NV_TRIM2_GET() \
    (uint16_t)((ee0x618 & 0xffffu) >> 0U)
/** R3_FL : R3_FL */
#define EE_R3_FL_GET() \
    (uint16_t)((ee0x618 & 0xffffu) >> 0U)
/** SW_VCTAT : Flash 32k : SW_VCTAT[1:0], set VCTAT voltage */
#define EE_SW_VCTAT_GET() \
    (uint8_t)((ee0x618 & 0xc000u) >> 14U)
/** VCTAT_EN : Flash 32k : VCTAT_EN  - activate VCTAT voltage; */
#define EE_VCTAT_EN_GET() \
    (uint8_t)((ee0x618 & 0x2000u) >> 13U)
/** EN_IREF1_BL : Flash 32k : EN_IREF1_BL  -  Enable pmos reference current (BL); */
#define EE_EN_IREF1_BL_GET() \
    (uint8_t)((ee0x618 & 0x1000u) >> 12U)
/** EN_IREF1_BLR : Flash 32k : EN_IREF1_BLR  -  Enable pmos reference current (BLR); */
#define EE_EN_IREF1_BLR_GET() \
    (uint8_t)((ee0x618 & 0x0800u) >> 11U)
/** VPTAT_EN : Flash 32k: VPTAT_EN  -  Enable VPTAT voltage; */
#define EE_VPTAT_EN_GET() \
    (uint8_t)((ee0x618 & 0x0400u) >> 10U)
/** YD : Flash 32k: Enable dummy bitline 1:0 */
#define EE_YD_GET() \
    (uint8_t)((ee0x618 & 0x0300u) >> 8U)
/** BLRES_ENA_1 : Flash 32k : BLRES_ENA[1]  -  Enable bitline reset; */
#define EE_BLRES_ENA_1_GET() \
    (uint8_t)((ee0x618 & 0x0080u) >> 7U)
/** TSEN : Flash 32K : TSEN - Sense time; */
#define EE_TSEN_GET() \
    (uint8_t)((ee0x618 & 0x0070u) >> 4U)
/** BLRES_ENA_0 : Flash 32k : BLRES_ENA[0] - Enable bitline reset; */
#define EE_BLRES_ENA_0_GET() \
    (uint8_t)((ee0x618 & 0x0008u) >> 3U)
/** TPRECH : Flash 32k : TPRECH - Pre-charge time; */
#define EE_TPRECH_GET() \
    (uint8_t)((ee0x618 & 0x0007u) >> 0U)
/** SW_VCTAT_64 : Flash 64k : SW_VCTAT[3:0], set VCTAT voltage */
#define EE_SW_VCTAT_64_GET() \
    (uint8_t)((ee0x618 & 0xf000u) >> 12U)
/** EN_IREF_BL_64 : Flash 64k : EN_IREF_BL  -  Enable pmos reference current (BL); */
#define EE_EN_IREF_BL_64_GET() \
    (uint8_t)((ee0x618 & 0x0800u) >> 11U)
/** EN_IREF_BLR_64 : Flash 64k : EN_IREF_BLR  -  Enable pmos reference current (BLR); */
#define EE_EN_IREF_BLR_64_GET() \
    (uint8_t)((ee0x618 & 0x0400u) >> 10U)
/** YD_64 : Flash 64k: Enable dummy bitline 1:0 */
#define EE_YD_64_GET() \
    (uint8_t)((ee0x618 & 0x0300u) >> 8U)
/** TSEN_64 : Flash 64k : TSEN - Sense time */
#define EE_TSEN_64_GET() \
    (uint8_t)((ee0x618 & 0x00e0u) >> 5U)
/** TPRECH_64 : Flash 64k : TPRECH - Pre-charge time; */
#define EE_TPRECH_64_GET() \
    (uint8_t)((ee0x618 & 0x001cu) >> 2U)
/** TINIT_64 : Flash 64k : TINIT - Init read timing */
#define EE_TINIT_64_GET() \
    (uint8_t)((ee0x618 & 0x0003u) >> 0U)
/** NV_TRIM3 : R2_FL */
#define EE_NV_TRIM3_GET() \
    (uint16_t)((ee0x61a & 0xffffu) >> 0U)
/** R2_FL : R2_FL */
#define EE_R2_FL_GET() \
    (uint16_t)((ee0x61a & 0xffffu) >> 0U)
/** T_MEAS : Flash 32k: T_MEAS[3:0]; Flash 64k: T_MEAS[4:1] - measurement test modes */
#define EE_T_MEAS_GET() \
    (uint8_t)((ee0x61a & 0xf000u) >> 12U)
/** SW_IREF_X2 : Flash 32k: double IREF for margin mode; Flash 64k: T_MEAS[0] */
#define EE_SW_IREF_X2_GET() \
    (uint8_t)((ee0x61a & 0x0800u) >> 11U)
/** SW_IREF : set IREF for margin mode */
#define EE_SW_IREF_GET() \
    (uint8_t)((ee0x61a & 0x07e0u) >> 5U)
/** SW_VMG : VMG voltage Flash and EEPROM */
#define EE_SW_VMG_GET() \
    (uint8_t)((ee0x61a & 0x001fu) >> 0U)
/** NV_TRIM4 : R1_FL */
#define EE_NV_TRIM4_GET() \
    (uint16_t)((ee0x61c & 0xffffu) >> 0U)
/** R1_FL : R1_FL */
#define EE_R1_FL_GET() \
    (uint16_t)((ee0x61c & 0xffffu) >> 0U)
/** DIS_ALL_MG : disable all MG */
#define EE_DIS_ALL_MG_GET() \
    (uint8_t)((ee0x61c & 0x8000u) >> 15U)
/** WNV_MODE : write modes */
#define EE_WNV_MODE_GET() \
    (uint8_t)((ee0x61c & 0x7000u) >> 12U)
/** CP_DIS_SG : disable SG CP */
#define EE_CP_DIS_SG_GET() \
    (uint8_t)((ee0x61c & 0x0800u) >> 11U)
/** CP_SC_FL : disable second CP chain */
#define EE_CP_SC_FL_GET() \
    (uint8_t)((ee0x61c & 0x0400u) >> 10U)
/** ERA_MODE : erase modes */
#define EE_ERA_MODE_GET() \
    (uint8_t)((ee0x61c & 0x0300u) >> 8U)
/** TR_PCP1_W_FL : Flash program voltage */
#define EE_TR_PCP1_W_FL_GET() \
    (uint8_t)((ee0x61c & 0x00f0u) >> 4U)
/** TR_PCP1_E_FL : Flash Erase voltage */
#define EE_TR_PCP1_E_FL_GET() \
    (uint8_t)((ee0x61c & 0x000fu) >> 0U)
/** NV_TRIM5 : EEPROM read timing port */
#define EE_NV_TRIM5_GET() \
    (uint16_t)((ee0x61e & 0xffffu) >> 0U)
/** EE_LOCK_RD : lock this port */
#define EE_EE_LOCK_RD_GET() \
    (uint8_t)((ee0x61e & 0x8000u) >> 15U)
/** EE_WAIT_STATES
 * (EE_WAIT_STATES +1) is the number of clock pulses to have a stable read data
 * Ready delay = (EE_WAIT_STATES + 2) * MCU_CLK
 */
#define EE_EE_WAIT_STATES_GET() \
    (uint8_t)((ee0x61e & 0x0f00u) >> 8U)
/** EE_HALT_BEHAVIOR : Define the EEPROM behavior when application is halted */
#define EE_EE_HALT_BEHAVIOR_GET() \
    (uint8_t)((ee0x61e & 0x0003u) >> 0U)
/** NV_TRIM6 : EEPROM program cycle port */
#define EE_NV_TRIM6_GET() \
    (uint16_t)((ee0x620 & 0xffffu) >> 0U)
/** EE_PROGRAM_CYCLE_LOCK : lock this port */
#define EE_EE_PROGRAM_CYCLE_LOCK_GET() \
    (uint8_t)((ee0x620 & 0x8000u) >> 15U)
/** EE_PROGRAM_CYCLE
 * This field defined the number of program cycles needed for writing a word in the EEPROM
 * Number of program cycles = EE_PROGRAM_CYCLE + 1
 */
#define EE_EE_PROGRAM_CYCLE_GET() \
    (uint8_t)((ee0x620 & 0x001fu) >> 0U)
/** NV_TRIM7 : EEPROM erase timing */
#define EE_NV_TRIM7_GET() \
    (uint16_t)((ee0x622 & 0xffffu) >> 0U)
/** EE_LOCK_ER : lock this port */
#define EE_EE_LOCK_ER_GET() \
    (uint8_t)((ee0x622 & 0x8000u) >> 15U)
/** EE_ER_TIME : Erase time = (EE_ER_TIME + 1) * 100us */
#define EE_EE_ER_TIME_GET() \
    (uint8_t)((ee0x622 & 0x003fu) >> 0U)
/** NV_TRIM8 : EEPROM write timing */
#define EE_NV_TRIM8_GET() \
    (uint16_t)((ee0x624 & 0xffffu) >> 0U)
/** EE_LOCK_WR : lock this port */
#define EE_EE_LOCK_WR_GET() \
    (uint8_t)((ee0x624 & 0x8000u) >> 15U)
/** EE_WR_TIME : Write time = (EE_WR_TIME + 1) * 10us */
#define EE_EE_WR_TIME_GET() \
    (uint8_t)((ee0x624 & 0x7f00u) >> 8U)
/** EE_PRE_WR_TIME : Pre-Write time = (EE_PRE_WR_TIME + 1) * 10us */
#define EE_EE_PRE_WR_TIME_GET() \
    (uint8_t)((ee0x624 & 0x007fu) >> 0U)
/** NV_TRIM9 : Flash read configuration word */
#define EE_NV_TRIM9_GET() \
    (uint16_t)((ee0x626 & 0xffffu) >> 0U)
/** FL_LOCK_RDY : lock this port */
#define EE_FL_LOCK_RDY_GET() \
    (uint8_t)((ee0x626 & 0x8000u) >> 15U)
/** FL_HALT_BEHAVIOR : Define the flash behavior when application is halted */
#define EE_FL_HALT_BEHAVIOR_GET() \
    (uint8_t)((ee0x626 & 0x3000u) >> 12U)
/** FL_DED_RETRY : number of re-try in case of Double Error Detect (DED) */
#define EE_FL_DED_RETRY_GET() \
    (uint8_t)((ee0x626 & 0x0700u) >> 8U)
/** FL_PREDICTION_BEHAVIOR : Define the behavior of the flash prediction */
#define EE_FL_PREDICTION_BEHAVIOR_GET() \
    (uint8_t)((ee0x626 & 0x00c0u) >> 6U)
/** FL_BYPASS_QUEUE : Define if Queue is used */
#define EE_FL_BYPASS_QUEUE_GET() \
    (uint8_t)((ee0x626 & 0x0010u) >> 4U)
/** FL_WAIT_STATES : Number of clock pulses between the read access start and the wishbone READY rising edge. */
#define EE_FL_WAIT_STATES_GET() \
    (uint8_t)((ee0x626 & 0x0007u) >> 0U)
/** NV_TRIM10 : Flash erase/write timing */
#define EE_NV_TRIM10_GET() \
    (uint16_t)((ee0x628 & 0xffffu) >> 0U)
/** FL_LOCK_ER_WR : lock this port */
#define EE_FL_LOCK_ER_WR_GET() \
    (uint8_t)((ee0x628 & 0x8000u) >> 15U)
/** FL_WR_TIME : Write time = (FL_WR_TIME + 1) * 100us */
#define EE_FL_WR_TIME_GET() \
    (uint8_t)((ee0x628 & 0x7f00u) >> 8U)
/** FL_ER_TIME : Erase time = (FL_ER_TIME + 1) * 100us */
#define EE_FL_ER_TIME_GET() \
    (uint8_t)((ee0x628 & 0x00ffu) >> 0U)
/** NV_TRIM11 : Timing Port2 */
#define EE_NV_TRIM11_GET() \
    (uint16_t)((ee0x62a & 0xffffu) >> 0U)
/** LOCK_T_1US : lock this port */
#define EE_LOCK_T_1US_GET() \
    (uint8_t)((ee0x62a & 0x8000u) >> 15U)
/** R3_FL_FLASH_15_13 : R3_FL[15:13] = VCTAT enable for flash (starting from Flash 1.4) */
#define EE_R3_FL_FLASH_15_13_GET() \
    (uint8_t)((ee0x62a & 0x0e00u) >> 9U)
/** T_1US : control the 1us time in the flash shell */
#define EE_T_1US_GET() \
    (uint8_t)((ee0x62a & 0x001fu) >> 0U)
/** NV_TRIM12 : Timing Port1 */
#define EE_NV_TRIM12_GET() \
    (uint16_t)((ee0x62c & 0xffffu) >> 0U)
/** LOCK_T : lock this port */
#define EE_LOCK_T_GET() \
    (uint8_t)((ee0x62c & 0x8000u) >> 15U)
/** T_50US : control the 50us time in the flash shell */
#define EE_T_50US_GET() \
    (uint8_t)((ee0x62c & 0x7c00u) >> 10U)
/** T_10US : control the 10us time in the flash shell */
#define EE_T_10US_GET() \
    (uint8_t)((ee0x62c & 0x03e0u) >> 5U)
/** T_50NS : control the 50ns time in the flash shell */
#define EE_T_50NS_GET() \
    (uint8_t)((ee0x62c & 0x001cu) >> 2U)
/** T_10NS : control the 10ns time in the flash shell */
#define EE_T_10NS_GET() \
    (uint8_t)((ee0x62c & 0x0001u) >> 0U)
/** NV_TRIM13 : NV memory, open */
#define EE_NV_TRIM13_GET() \
    (uint16_t)((ee0x62e & 0xffffu) >> 0U)
/** CHIPID0 : Chip ID0 readable by application - copy of MLX TestChipId0 */
#define EE_CHIPID0_GET() \
    (uint16_t)((ee0x630 & 0xffffu) >> 0U)
/** APP_D_YPOS_ID : Copy of TEST_CHIP_ID0 */
#define EE_APP_D_YPOS_ID_GET() \
    (uint8_t)((ee0x630 & 0xff00u) >> 8U)
/** APP_D_XPOS_ID : Copy of TEST_CHIP_ID0 */
#define EE_APP_D_XPOS_ID_GET() \
    (uint8_t)((ee0x630 & 0x00ffu) >> 0U)
/** CHIPID1 : Chip ID1 readable by application - copy of MLX TestChipId1 */
#define EE_CHIPID1_GET() \
    (uint16_t)((ee0x632 & 0xffffu) >> 0U)
/** APP_D_LOT_ID_H : Copy of TEST_CHIP_ID1 */
#define EE_APP_D_LOT_ID_H_GET() \
    (uint16_t)((ee0x632 & 0xffe0u) >> 5U)
/** APP_D_WFR_ID : Copy of TEST_CHIP_ID1 */
#define EE_APP_D_WFR_ID_GET() \
    (uint8_t)((ee0x632 & 0x001fu) >> 0U)
/** CHIPID2 : Copy of TEST_CHIP_ID2 */
#define EE_CHIPID2_GET() \
    (uint16_t)((ee0x634 & 0xffffu) >> 0U)
/** APP_D_CORDAT6_ID : Chip ID2 readable by application - copy of MLX TestChipId2 */
#define EE_APP_D_CORDAT6_ID_GET() \
    (uint8_t)((ee0x634 & 0xfc00u) >> 10U)
/** APP_D_FAB_ID : Copy of TEST_CHIP_ID2 */
#define EE_APP_D_FAB_ID_GET() \
    (uint8_t)((ee0x634 & 0x03c0u) >> 6U)
/** APP_D_LOT_ID_L : Copy of TEST_CHIP_ID2 */
#define EE_APP_D_LOT_ID_L_GET() \
    (uint8_t)((ee0x634 & 0x003fu) >> 0U)
/** PROJECT_ID : Copy of Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_PROJECT_ID_GET() \
    (uint16_t)((ee0x636 & 0xffffu) >> 0U)
/** CHIPID3 : Copy of TEST_CHIP_ID3 */
#define EE_CHIPID3_GET() \
    (uint16_t)((ee0x636 & 0xffffu) >> 0U)
/** APP_PROJECT_ID : Unique PROJECT_ID for software use */
#define EE_APP_PROJECT_ID_GET() \
    (uint16_t)((ee0x636 & 0xffffu) >> 0U)
/** TESTCHIPID0 : MLX TestChipID0 created by test program */
#define EE_TESTCHIPID0_GET() \
    (uint16_t)((ee0x638 & 0xffffu) >> 0U)
/** MLX_ID0 : Melexis IC test identification data */
#define EE_MLX_ID0_GET() \
    (uint16_t)((ee0x638 & 0xffffu) >> 0U)
/** D_CHIP_ID : Melexis IC test identification data D_CHIP ID[20:0] */
#define EE_D_CHIP_ID_GET() \
    (uint16_t)((ee0x638 & 0x1fffffu) >> 0U)
/** D_YPOS_ID : Y position */
#define EE_D_YPOS_ID_GET() \
    (uint8_t)((ee0x638 & 0xff00u) >> 8U)
/** D_XPOS_ID : X position */
#define EE_D_XPOS_ID_GET() \
    (uint8_t)((ee0x638 & 0x00ffu) >> 0U)
/** TESTCHIPID1 : MLX TestChipId1 created by test program */
#define EE_TESTCHIPID1_GET() \
    (uint16_t)((ee0x63a & 0xffffu) >> 0U)
/** MLX_ID1 : Melexis IC test identification data */
#define EE_MLX_ID1_GET() \
    (uint16_t)((ee0x63a & 0xffffu) >> 0U)
/** D_LOT_ID : Lot Number */
#define EE_D_LOT_ID_GET() \
    (uint16_t)((ee0x63a & 0x3fffe0u) >> 5U)
/** D_LOT_ID_LSB11 : Lot Number [10:0] */
#define EE_D_LOT_ID_LSB11_GET() \
    (uint16_t)((ee0x63a & 0xffe0u) >> 5U)
/** D_WFR_ID : Wafer number */
#define EE_D_WFR_ID_GET() \
    (uint8_t)((ee0x63a & 0x001fu) >> 0U)
/** TESTCHIPID2 : MLX TestChipId2 created by test program */
#define EE_TESTCHIPID2_GET() \
    (uint16_t)((ee0x63c & 0xffffu) >> 0U)
/** MLX_ID2 : Melexis IC test identification data */
#define EE_MLX_ID2_GET() \
    (uint16_t)((ee0x63c & 0xffffu) >> 0U)
/** D_CORDAT_ID : Melexis IC test identification data */
#define EE_D_CORDAT_ID_GET() \
    (uint8_t)((ee0x63c & 0xfc00u) >> 10U)
/** D_FAB_ID : FAB id number */
#define EE_D_FAB_ID_GET() \
    (uint8_t)((ee0x63c & 0x03c0u) >> 6U)
/** D_LOT_ID_MSB6 : Lot Number [16:11] */
#define EE_D_LOT_ID_MSB6_GET() \
    (uint8_t)((ee0x63c & 0x003fu) >> 0U)
/** TESTCHIPID3 : Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_TESTCHIPID3_GET() \
    (uint16_t)((ee0x63e & 0xffffu) >> 0U)
/** TEST_PROJECT_ID : Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_TEST_PROJECT_ID_GET() \
    (uint16_t)((ee0x63e & 0xffffu) >> 0U)

/*****************************************************************************/
/* 3.3 Fields. */

/**
 * Description of the records from left to right:
 * EE, underscore, field name.
 * Hosting variable.
 * Absolute word address of the field. Also location of the host variable.
 * Absolute byte address of the field.
 * Bit mask, showing the meaningful bits of the field inside the host.
 * Offset, shows the location of the first significant bit of the mask.
 * Boolean true (1U) or false (0U), showing whether the field is writable.
 * Triboolean, showing whether the field is bit accessible i.e. the assembler
 *    operation setb, clrb and mov c can be used for it. The value 2U is
 *    reserved for MlxCCT's private dummy fields.
 * Bit mask, showing which bits of the host variable are not occupied.
 */

/** PATCH_LEN - High byte : PATCH Length */
#define EE_PATCH_LEN \
    ee0x400, (MEM_EEPROM_START + 0x0000u), (MEM_EEPROM_START + 0x0000u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** PATCH_CRC - Low byte : Calculated CRC over patch addresses */
#define EE_PATCH_CRC \
    ee0x400, (MEM_EEPROM_START + 0x0000u), (MEM_EEPROM_START + 0x0000u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** PATCH_ID - ID of the patch */
#define EE_PATCH_ID \
    ee0x402, (MEM_EEPROM_START + 0x0002u), (MEM_EEPROM_START + 0x0002u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH0_ADR - DEBUG_ADR0 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH0_ADR \
    ee0x404, (MEM_EEPROM_START + 0x0004u), (MEM_EEPROM_START + 0x0004u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH0_DATA - DEBUG_DATA0 (replacement instr) */
#define EE_PATCH0_DATA \
    ee0x406, (MEM_EEPROM_START + 0x0006u), (MEM_EEPROM_START + 0x0006u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH1_ADR - DEBUG_ADR1 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH1_ADR \
    ee0x408, (MEM_EEPROM_START + 0x0008u), (MEM_EEPROM_START + 0x0008u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH1_DATA - DEBUG_DATA1 (replacement instr) */
#define EE_PATCH1_DATA \
    ee0x40a, (MEM_EEPROM_START + 0x000au), (MEM_EEPROM_START + 0x000au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH2_ADR - DEBUG_ADR2 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH2_ADR \
    ee0x40c, (MEM_EEPROM_START + 0x000cu), (MEM_EEPROM_START + 0x000cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH2_DATA - DEBUG_DATA2 (replacement instr) */
#define EE_PATCH2_DATA \
    ee0x40e, (MEM_EEPROM_START + 0x000eu), (MEM_EEPROM_START + 0x000eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE00 - patch code in EEPROM */
#define EE_PATCH_CODE00 \
    ee0x410, (MEM_EEPROM_START + 0x0010u), (MEM_EEPROM_START + 0x0010u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE01 - patch code in EEPROM */
#define EE_PATCH_CODE01 \
    ee0x412, (MEM_EEPROM_START + 0x0012u), (MEM_EEPROM_START + 0x0012u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE02 - patch code in EEPROM */
#define EE_PATCH_CODE02 \
    ee0x414, (MEM_EEPROM_START + 0x0014u), (MEM_EEPROM_START + 0x0014u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE03 - patch code in EEPROM */
#define EE_PATCH_CODE03 \
    ee0x416, (MEM_EEPROM_START + 0x0016u), (MEM_EEPROM_START + 0x0016u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE04 - patch code in EEPROM */
#define EE_PATCH_CODE04 \
    ee0x418, (MEM_EEPROM_START + 0x0018u), (MEM_EEPROM_START + 0x0018u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE05 - patch code in EEPROM */
#define EE_PATCH_CODE05 \
    ee0x41a, (MEM_EEPROM_START + 0x001au), (MEM_EEPROM_START + 0x001au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE06 - patch code in EEPROM */
#define EE_PATCH_CODE06 \
    ee0x41c, (MEM_EEPROM_START + 0x001cu), (MEM_EEPROM_START + 0x001cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE07 - patch code in EEPROM */
#define EE_PATCH_CODE07 \
    ee0x41e, (MEM_EEPROM_START + 0x001eu), (MEM_EEPROM_START + 0x001eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE08 - patch code in EEPROM */
#define EE_PATCH_CODE08 \
    ee0x420, (MEM_EEPROM_START + 0x0020u), (MEM_EEPROM_START + 0x0020u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE09 - patch code in EEPROM */
#define EE_PATCH_CODE09 \
    ee0x422, (MEM_EEPROM_START + 0x0022u), (MEM_EEPROM_START + 0x0022u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE10 - patch code in EEPROM */
#define EE_PATCH_CODE10 \
    ee0x424, (MEM_EEPROM_START + 0x0024u), (MEM_EEPROM_START + 0x0024u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE11 - patch code in EEPROM */
#define EE_PATCH_CODE11 \
    ee0x426, (MEM_EEPROM_START + 0x0026u), (MEM_EEPROM_START + 0x0026u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE12 - patch code in EEPROM */
#define EE_PATCH_CODE12 \
    ee0x428, (MEM_EEPROM_START + 0x0028u), (MEM_EEPROM_START + 0x0028u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE13 - patch code in EEPROM */
#define EE_PATCH_CODE13 \
    ee0x42a, (MEM_EEPROM_START + 0x002au), (MEM_EEPROM_START + 0x002au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE14 - patch code in EEPROM */
#define EE_PATCH_CODE14 \
    ee0x42c, (MEM_EEPROM_START + 0x002cu), (MEM_EEPROM_START + 0x002cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE15 - patch code in EEPROM */
#define EE_PATCH_CODE15 \
    ee0x42e, (MEM_EEPROM_START + 0x002eu), (MEM_EEPROM_START + 0x002eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE16 - patch code in EEPROM */
#define EE_PATCH_CODE16 \
    ee0x430, (MEM_EEPROM_START + 0x0030u), (MEM_EEPROM_START + 0x0030u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE17 - patch code in EEPROM */
#define EE_PATCH_CODE17 \
    ee0x432, (MEM_EEPROM_START + 0x0032u), (MEM_EEPROM_START + 0x0032u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE18 - patch code in EEPROM */
#define EE_PATCH_CODE18 \
    ee0x434, (MEM_EEPROM_START + 0x0034u), (MEM_EEPROM_START + 0x0034u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE19 - patch code in EEPROM */
#define EE_PATCH_CODE19 \
    ee0x436, (MEM_EEPROM_START + 0x0036u), (MEM_EEPROM_START + 0x0036u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE20 - patch code in EEPROM */
#define EE_PATCH_CODE20 \
    ee0x438, (MEM_EEPROM_START + 0x0038u), (MEM_EEPROM_START + 0x0038u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE21 - patch code in EEPROM */
#define EE_PATCH_CODE21 \
    ee0x43a, (MEM_EEPROM_START + 0x003au), (MEM_EEPROM_START + 0x003au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE22 - patch code in EEPROM */
#define EE_PATCH_CODE22 \
    ee0x43c, (MEM_EEPROM_START + 0x003cu), (MEM_EEPROM_START + 0x003cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE23 - patch code in EEPROM */
#define EE_PATCH_CODE23 \
    ee0x43e, (MEM_EEPROM_START + 0x003eu), (MEM_EEPROM_START + 0x003eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM0 - {TempMid[7:0], CalibCRC_EE[7:0]} */
#define EE_APP_TRIM0 \
    ee0x5b0, (MEM_EEPROM_START + 0x01b0u), (MEM_EEPROM_START + 0x01b0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TEMPMID - Middle Temperature used in production (mostly probing1 = 35degC) (copy at 09B6) */
#define EE_TEMPMID \
    ee0x5b0, (MEM_EEPROM_START + 0x01b0u), (MEM_EEPROM_START + 0x01b0u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** CALIBCRC - 8bit EEPROM calibration area CRC ( sum with carry ) */
#define EE_CALIBCRC \
    ee0x5b0, (MEM_EEPROM_START + 0x01b0u), (MEM_EEPROM_START + 0x01b0u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM1 - reserved[15:0] */
#define EE_APP_TRIM1 \
    ee0x5b2, (MEM_EEPROM_START + 0x01b2u), (MEM_EEPROM_START + 0x01b2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_VSMF - Offset of VSMF/26 input at mid temperature */
#define EE_O_VSMF \
    ee0x5b2, (MEM_EEPROM_START + 0x01b2u), (MEM_EEPROM_START + 0x01b2u), 0x0fffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM2 - OTempCal_EE[15:0] */
#define EE_APP_TRIM2 \
    ee0x5b4, (MEM_EEPROM_START + 0x01b4u), (MEM_EEPROM_START + 0x01b4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** OTEMPCAL - Temperature Sensor Offset , 16bit unsigned */
#define EE_OTEMPCAL \
    ee0x5b4, (MEM_EEPROM_START + 0x01b4u), (MEM_EEPROM_START + 0x01b4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM3 - {CALIB_VERSION[7:0], TempMid[7:0]} */
#define EE_APP_TRIM3 \
    ee0x5b6, (MEM_EEPROM_START + 0x01b6u), (MEM_EEPROM_START + 0x01b6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** CALIB_VERSION - Calibration data version */
#define EE_CALIB_VERSION \
    ee0x5b6, (MEM_EEPROM_START + 0x01b6u), (MEM_EEPROM_START + 0x01b6u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** TEMPMID_CP - Middle Temperature used in production (mostly probing1 = 35degC) (copy at 09B1) */
#define EE_TEMPMID_CP \
    ee0x5b6, (MEM_EEPROM_START + 0x01b6u), (MEM_EEPROM_START + 0x01b6u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM4 - {GainTempHighCal_EE[7:0], GainTempLowCal_EE[7:0]} */
#define EE_APP_TRIM4 \
    ee0x5b8, (MEM_EEPROM_START + 0x01b8u), (MEM_EEPROM_START + 0x01b8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINTEMPHIGHCAL - Temp sensor calibration, Gain for High Temp range */
#define EE_GAINTEMPHIGHCAL \
    ee0x5b8, (MEM_EEPROM_START + 0x01b8u), (MEM_EEPROM_START + 0x01b8u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINTEMPLOWCAL - Temp sensor calibration, Gain for Low Temp range */
#define EE_GAINTEMPLOWCAL \
    ee0x5b8, (MEM_EEPROM_START + 0x01b8u), (MEM_EEPROM_START + 0x01b8u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM5 - {reserved[2:0],LINAA_DIV_EXT[4:0], OADCCal_EE[7:0]} */
#define EE_APP_TRIM5 \
    ee0x5ba, (MEM_EEPROM_START + 0x01bau), (MEM_EEPROM_START + 0x01bau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_DIV_EXT - extended 5bit LINAA_DIV control for CMR adjustment */
#define EE_LINAA_DIV_EXT \
    ee0x5ba, (MEM_EEPROM_START + 0x01bau), (MEM_EEPROM_START + 0x01bau), 0x1f00u,  8U, 1U, 0U, 0x0000u
/** OADCCAL - ADC reference (2.5V) offset [8bit signed] */
#define EE_OADCCAL \
    ee0x5ba, (MEM_EEPROM_START + 0x01bau), (MEM_EEPROM_START + 0x01bau), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM6 - {GainADCHighCal_EE[7:0], GainADCLowCal_EE[7:0]} */
#define EE_APP_TRIM6 \
    ee0x5bc, (MEM_EEPROM_START + 0x01bcu), (MEM_EEPROM_START + 0x01bcu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINADCHIGHCAL - ADC reference (2.5V) gain for high temp range  [8bit signed] */
#define EE_GAINADCHIGHCAL \
    ee0x5bc, (MEM_EEPROM_START + 0x01bcu), (MEM_EEPROM_START + 0x01bcu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINADCLOWCAL - ADC reference (2.5V) gain for low temp range  [8bit signed] */
#define EE_GAINADCLOWCAL \
    ee0x5bc, (MEM_EEPROM_START + 0x01bcu), (MEM_EEPROM_START + 0x01bcu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** O_VBOOST_64_H - Offset of input VBOOST/64 at mid temp */
#define EE_O_VBOOST_64_H \
    ee0x5bc, (MEM_EEPROM_START + 0x01bcu), (MEM_EEPROM_START + 0x01bcu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** APP_TRIM7 - {SClock24HighCal _EE[7:0], SClock24LowCal _EE[7:0]} */
#define EE_APP_TRIM7 \
    ee0x5be, (MEM_EEPROM_START + 0x01beu), (MEM_EEPROM_START + 0x01beu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SCLOCK24HIGHCAL - CPU clock (24MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK24HIGHCAL \
    ee0x5be, (MEM_EEPROM_START + 0x01beu), (MEM_EEPROM_START + 0x01beu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** SCLOCK24LOWCAL - CPU clock (24MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK24LOWCAL \
    ee0x5be, (MEM_EEPROM_START + 0x01beu), (MEM_EEPROM_START + 0x01beu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** GAINHI_CURR_G20 - Gain-change of current sensor input * 20 over high temperature range */
#define EE_GAINHI_CURR_G20 \
    ee0x5be, (MEM_EEPROM_START + 0x01beu), (MEM_EEPROM_START + 0x01beu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINLO_CURR_G20 - Gain-change of current sensor input * 20 over low temperature range */
#define EE_GAINLO_CURR_G20 \
    ee0x5be, (MEM_EEPROM_START + 0x01beu), (MEM_EEPROM_START + 0x01beu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM8 - {SClock28LowCal _EE[7:0], OClock24Cal _EE[7:0]} */
#define EE_APP_TRIM8 \
    ee0x5c0, (MEM_EEPROM_START + 0x01c0u), (MEM_EEPROM_START + 0x01c0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SCLOCK28LOWCAL - CPU clock (28MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK28LOWCAL \
    ee0x5c0, (MEM_EEPROM_START + 0x01c0u), (MEM_EEPROM_START + 0x01c0u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** OCLOCK24CAL - CPU clock (24MHz)  Offset [8bit signed] */
#define EE_OCLOCK24CAL \
    ee0x5c0, (MEM_EEPROM_START + 0x01c0u), (MEM_EEPROM_START + 0x01c0u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** O_CURR_G20_L - Offset of current sensor input * 20 at mid temp */
#define EE_O_CURR_G20_L \
    ee0x5c0, (MEM_EEPROM_START + 0x01c0u), (MEM_EEPROM_START + 0x01c0u), 0xf000u, 12U, 1U, 0U, 0x0000u
/** GAIN_CURR_G20 - Gain of current sensor input * 20 at mid temp */
#define EE_GAIN_CURR_G20 \
    ee0x5c0, (MEM_EEPROM_START + 0x01c0u), (MEM_EEPROM_START + 0x01c0u), 0x0fffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM9 - {OClock28Cal _EE[7:0], SClock28HighCal _EE[7:0]} */
#define EE_APP_TRIM9 \
    ee0x5c2, (MEM_EEPROM_START + 0x01c2u), (MEM_EEPROM_START + 0x01c2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** OCLOCK28CAL - CPU clock (28MHz)  Offset [8bit signed] */
#define EE_OCLOCK28CAL \
    ee0x5c2, (MEM_EEPROM_START + 0x01c2u), (MEM_EEPROM_START + 0x01c2u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** SCLOCK28HIGHCAL - CPU clock (28MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK28HIGHCAL \
    ee0x5c2, (MEM_EEPROM_START + 0x01c2u), (MEM_EEPROM_START + 0x01c2u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** O_CURR_G20_H - Offset of current sensor input * 20 at mid temp */
#define EE_O_CURR_G20_H \
    ee0x5c2, (MEM_EEPROM_START + 0x01c2u), (MEM_EEPROM_START + 0x01c2u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM10 - {SClock32HighCal _EE[7:0], SClock32LowCal _EE[7:0]} */
#define EE_APP_TRIM10 \
    ee0x5c4, (MEM_EEPROM_START + 0x01c4u), (MEM_EEPROM_START + 0x01c4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SCLOCK32HIGHCAL - CPU clock (30MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK32HIGHCAL \
    ee0x5c4, (MEM_EEPROM_START + 0x01c4u), (MEM_EEPROM_START + 0x01c4u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** SCLOCK32LOWCAL - CPU clock (30MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK32LOWCAL \
    ee0x5c4, (MEM_EEPROM_START + 0x01c4u), (MEM_EEPROM_START + 0x01c4u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM11 - {O10kHzCal_EE[7:0], OClock32Cal _EE[7:0]} */
#define EE_APP_TRIM11 \
    ee0x5c6, (MEM_EEPROM_START + 0x01c6u), (MEM_EEPROM_START + 0x01c6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O10KHZCAL - Wake up Clock Offset [8bit signed] */
#define EE_O10KHZCAL \
    ee0x5c6, (MEM_EEPROM_START + 0x01c6u), (MEM_EEPROM_START + 0x01c6u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** OCLOCK32CAL - CPU clock (30MHz)  Offset [8bit signed] */
#define EE_OCLOCK32CAL \
    ee0x5c6, (MEM_EEPROM_START + 0x01c6u), (MEM_EEPROM_START + 0x01c6u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM12 - Rshunt from the LIN autoconfig block */
#define EE_APP_TRIM12 \
    ee0x5c8, (MEM_EEPROM_START + 0x01c8u), (MEM_EEPROM_START + 0x01c8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_INT_SHUNT - Rshunt from the LIN autoconfig block */
#define EE_LINAA_INT_SHUNT \
    ee0x5c8, (MEM_EEPROM_START + 0x01c8u), (MEM_EEPROM_START + 0x01c8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINHI_PHASE_52 - Gain-change of phase input HVI/52 over high temperature range */
#define EE_GAINHI_PHASE_52 \
    ee0x5c8, (MEM_EEPROM_START + 0x01c8u), (MEM_EEPROM_START + 0x01c8u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINLO_PHASE_52 - Gain-change of phase input HVI/52 over low temperature range */
#define EE_GAINLO_PHASE_52 \
    ee0x5c8, (MEM_EEPROM_START + 0x01c8u), (MEM_EEPROM_START + 0x01c8u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM13 - reserved[15:0] */
#define EE_APP_TRIM13 \
    ee0x5ca, (MEM_EEPROM_START + 0x01cau), (MEM_EEPROM_START + 0x01cau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_PHASE_52_L - Offset of phase input HVI/52 at mid temperature */
#define EE_O_PHASE_52_L \
    ee0x5ca, (MEM_EEPROM_START + 0x01cau), (MEM_EEPROM_START + 0x01cau), 0xf000u, 12U, 1U, 0U, 0x0000u
/** GAIN_PHASE_52 - Gain of phase input HVI/52 at mid temperature */
#define EE_GAIN_PHASE_52 \
    ee0x5ca, (MEM_EEPROM_START + 0x01cau), (MEM_EEPROM_START + 0x01cau), 0x0fffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM14 - LINAA_SDMCM_EE[15:0] */
#define EE_APP_TRIM14 \
    ee0x5cc, (MEM_EEPROM_START + 0x01ccu), (MEM_EEPROM_START + 0x01ccu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_SDMCM - LINAA - differential current measurement sensitivity to common mode voltage step */
#define EE_LINAA_SDMCM \
    ee0x5cc, (MEM_EEPROM_START + 0x01ccu), (MEM_EEPROM_START + 0x01ccu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINLO_VSMF_52 - Gain-change of VSMF/52 input over low temperature range */
#define EE_GAINLO_VSMF_52 \
    ee0x5cc, (MEM_EEPROM_START + 0x01ccu), (MEM_EEPROM_START + 0x01ccu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** O_PHASE_52_H - Offset of phase input HVI/52 at mid temperature */
#define EE_O_PHASE_52_H \
    ee0x5cc, (MEM_EEPROM_START + 0x01ccu), (MEM_EEPROM_START + 0x01ccu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM15 - LINAA_GainDMCal_EE [15:0] */
#define EE_APP_TRIM15 \
    ee0x5ce, (MEM_EEPROM_START + 0x01ceu), (MEM_EEPROM_START + 0x01ceu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_GAINDMCAL - LINAA - differential current measurement sensitivity to  current */
#define EE_LINAA_GAINDMCAL \
    ee0x5ce, (MEM_EEPROM_START + 0x01ceu), (MEM_EEPROM_START + 0x01ceu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAIN_VSMF_52_L - Gain of VSMF/52 input at mid temperature */
#define EE_GAIN_VSMF_52_L \
    ee0x5ce, (MEM_EEPROM_START + 0x01ceu), (MEM_EEPROM_START + 0x01ceu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINHI_VSMF_52 - Gain-change of VSMF/52 input over high temperature range */
#define EE_GAINHI_VSMF_52 \
    ee0x5ce, (MEM_EEPROM_START + 0x01ceu), (MEM_EEPROM_START + 0x01ceu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM16 - {IAA_Trim205mA[7:0], IAA_Trim045mA[7:0]} */
#define EE_APP_TRIM16 \
    ee0x5d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_LCD_SEL_205 - IAA_Trim205mA[7:6]: current selection for low side diagnosis current source for 205mA */
#define EE_LINAA_LCD_SEL_205 \
    ee0x5d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0xc000u, 14U, 1U, 0U, 0x0000u
/** LINAA_TRIM_LCD_205 - IAA_Trim205mA[5:0]:  trimming for low side diagnosis current source for 205mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_205 \
    ee0x5d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x3f00u,  8U, 1U, 0U, 0x0000u
/** LINAA_LCD_SEL_112 - IAA_Trim045mA[7:6]: current selection for low side diagnosis current source for 0.45mA */
#define EE_LINAA_LCD_SEL_112 \
    ee0x5d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x00c0u,  6U, 1U, 0U, 0x0000u
/** LINAA_TRIM_LCD_112 - IAA_Trim045mA[5:0]:  trimming for low side diagnosis current source for 0.45mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_112 \
    ee0x5d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** LINAA_LCD_SEL_045 - IAA_Trim045mA[7:6]: current selection for low side diagnosis current source for 0.45mA */
#define EE_LINAA_LCD_SEL_045 \
    ee0x5d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x00c0u,  6U, 1U, 0U, 0x0000u
/** LINAA_TRIM_LCD_045 - IAA_Trim045mA[5:0]:  trimming for low side diagnosis current source for 0.45mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_045 \
    ee0x5d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** O_VSMF_52 - Offset of VSMF/52 input at mid temperature */
#define EE_O_VSMF_52 \
    ee0x5d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0xfff0u,  4U, 1U, 0U, 0x0000u
/** GAIN_VSMF_52_H - Gain of VSMF/52 input at mid temperature */
#define EE_GAIN_VSMF_52_H \
    ee0x5d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x000fu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM17 - {LIN_AA_DIV[3:0], LINN_AA_GAIN[3:0], IAA_Trim240mA[7:0]} */
#define EE_APP_TRIM17 \
    ee0x5d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_DIV - Common mode suppression adjustements bits, copy to PORT_LINAA1 */
#define EE_LINAA_DIV \
    ee0x5d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0xf000u, 12U, 1U, 0U, 0x0000u
/** LINAA_GAIN - Gain control bits of the variable gain amp, , copy to PORT_LINAA1 */
#define EE_LINAA_GAIN \
    ee0x5d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0x0f00u,  8U, 1U, 0U, 0x0000u
/** LINAA_LCD_SEL_240 - IAA_Trim240mA[7:6]: current selection for low side diagnosis current source for 2.4mA */
#define EE_LINAA_LCD_SEL_240 \
    ee0x5d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0x00c0u,  6U, 1U, 0U, 0x0000u
/** LINAA_TRIM_LCD_240 - IAA_Trim240mA[5:0]:  trimming for low side diagnosis current source for 2.4mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_240 \
    ee0x5d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM18 - application specific calibration information */
#define EE_APP_TRIM18 \
    ee0x5d4, (MEM_EEPROM_START + 0x01d4u), (MEM_EEPROM_START + 0x01d4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINHI_VSMF - Gain-change of VSMF/26 input at high temperature */
#define EE_GAINHI_VSMF \
    ee0x5d4, (MEM_EEPROM_START + 0x01d4u), (MEM_EEPROM_START + 0x01d4u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINLO_VSMF - Gain-change of VSMF/26 input at low temperature */
#define EE_GAINLO_VSMF \
    ee0x5d4, (MEM_EEPROM_START + 0x01d4u), (MEM_EEPROM_START + 0x01d4u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM19 - application specific calibration information */
#define EE_APP_TRIM19 \
    ee0x5d6, (MEM_EEPROM_START + 0x01d6u), (MEM_EEPROM_START + 0x01d6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAIN_VSMF - Gain of VSMF/26 input at mid temperature */
#define EE_GAIN_VSMF \
    ee0x5d6, (MEM_EEPROM_START + 0x01d6u), (MEM_EEPROM_START + 0x01d6u), 0x0fffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM20 - application specific calibration information */
#define EE_APP_TRIM20 \
    ee0x5d8, (MEM_EEPROM_START + 0x01d8u), (MEM_EEPROM_START + 0x01d8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MTEMPLOW - Raw ADC measurement of temperature sensor at Low Test Temperature */
#define EE_MTEMPLOW \
    ee0x5d8, (MEM_EEPROM_START + 0x01d8u), (MEM_EEPROM_START + 0x01d8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM21 - application specific calibration information */
#define EE_APP_TRIM21 \
    ee0x5da, (MEM_EEPROM_START + 0x01dau), (MEM_EEPROM_START + 0x01dau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MTEMPHIGH - Raw ADC measurement of temperature sensor at High Test Temperature */
#define EE_MTEMPHIGH \
    ee0x5da, (MEM_EEPROM_START + 0x01dau), (MEM_EEPROM_START + 0x01dau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM22 - application specific calibration information */
#define EE_APP_TRIM22 \
    ee0x5dc, (MEM_EEPROM_START + 0x01dcu), (MEM_EEPROM_START + 0x01dcu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINHI_CURR - Gain-change of current sensor input * 10 over high temperature range */
#define EE_GAINHI_CURR \
    ee0x5dc, (MEM_EEPROM_START + 0x01dcu), (MEM_EEPROM_START + 0x01dcu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINLO_CURR - Gain-change of current sensor input * 10 over low temperature range */
#define EE_GAINLO_CURR \
    ee0x5dc, (MEM_EEPROM_START + 0x01dcu), (MEM_EEPROM_START + 0x01dcu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM23 - application specific calibration information */
#define EE_APP_TRIM23 \
    ee0x5de, (MEM_EEPROM_START + 0x01deu), (MEM_EEPROM_START + 0x01deu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_CURR_L - Offset of current sensor input * 10 at mid temp */
#define EE_O_CURR_L \
    ee0x5de, (MEM_EEPROM_START + 0x01deu), (MEM_EEPROM_START + 0x01deu), 0xf000u, 12U, 1U, 0U, 0x0000u
/** GAIN_CURR - Gain of current sensor input * 10 at mid temp */
#define EE_GAIN_CURR \
    ee0x5de, (MEM_EEPROM_START + 0x01deu), (MEM_EEPROM_START + 0x01deu), 0x0fffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM24 - application specific calibration information */
#define EE_APP_TRIM24 \
    ee0x5e0, (MEM_EEPROM_START + 0x01e0u), (MEM_EEPROM_START + 0x01e0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINLO_VBOOST - Gain-change of input VBOOST/32 over low temperature range */
#define EE_GAINLO_VBOOST \
    ee0x5e0, (MEM_EEPROM_START + 0x01e0u), (MEM_EEPROM_START + 0x01e0u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** O_CURR_H - Offset of current sensor input * 10 at mid temp */
#define EE_O_CURR_H \
    ee0x5e0, (MEM_EEPROM_START + 0x01e0u), (MEM_EEPROM_START + 0x01e0u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM25 - application specific calibration information */
#define EE_APP_TRIM25 \
    ee0x5e2, (MEM_EEPROM_START + 0x01e2u), (MEM_EEPROM_START + 0x01e2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAIN_VBOOST_L - Gain of input VBOOST/32 at mid temp */
#define EE_GAIN_VBOOST_L \
    ee0x5e2, (MEM_EEPROM_START + 0x01e2u), (MEM_EEPROM_START + 0x01e2u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINHI_VBOOST - Gain-change of input VBOOST/32 over high temperature range */
#define EE_GAINHI_VBOOST \
    ee0x5e2, (MEM_EEPROM_START + 0x01e2u), (MEM_EEPROM_START + 0x01e2u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM26 - application specific calibration information */
#define EE_APP_TRIM26 \
    ee0x5e4, (MEM_EEPROM_START + 0x01e4u), (MEM_EEPROM_START + 0x01e4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_VBOOST - Offset of input VBOOST/32 at mid temp */
#define EE_O_VBOOST \
    ee0x5e4, (MEM_EEPROM_START + 0x01e4u), (MEM_EEPROM_START + 0x01e4u), 0xfff0u,  4U, 1U, 0U, 0x0000u
/** GAIN_VBOOST_H - Gain of input VBOOST/32 at mid temp */
#define EE_GAIN_VBOOST_H \
    ee0x5e4, (MEM_EEPROM_START + 0x01e4u), (MEM_EEPROM_START + 0x01e4u), 0x000fu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM27 - application specific calibration information */
#define EE_APP_TRIM27 \
    ee0x5e6, (MEM_EEPROM_START + 0x01e6u), (MEM_EEPROM_START + 0x01e6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINHI_HVI - Gain-change of High-voltage input over high temperature range */
#define EE_GAINHI_HVI \
    ee0x5e6, (MEM_EEPROM_START + 0x01e6u), (MEM_EEPROM_START + 0x01e6u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINLO_HVI - Gain-change of High-voltage input over low temperature range */
#define EE_GAINLO_HVI \
    ee0x5e6, (MEM_EEPROM_START + 0x01e6u), (MEM_EEPROM_START + 0x01e6u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM28 - application specific calibration information */
#define EE_APP_TRIM28 \
    ee0x5e8, (MEM_EEPROM_START + 0x01e8u), (MEM_EEPROM_START + 0x01e8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_HVI_L - Gain of High-voltage input HVI/26 at mid temp */
#define EE_O_HVI_L \
    ee0x5e8, (MEM_EEPROM_START + 0x01e8u), (MEM_EEPROM_START + 0x01e8u), 0xf000u, 12U, 1U, 0U, 0x0000u
/** GAIN_HVI - Gain of High-voltage input HVI/26 at mid temp */
#define EE_GAIN_HVI \
    ee0x5e8, (MEM_EEPROM_START + 0x01e8u), (MEM_EEPROM_START + 0x01e8u), 0x0fffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM29 - application specific calibration information */
#define EE_APP_TRIM29 \
    ee0x5ea, (MEM_EEPROM_START + 0x01eau), (MEM_EEPROM_START + 0x01eau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINLO_LVI - Gain-change of Low-voltage input over low temperature range */
#define EE_GAINLO_LVI \
    ee0x5ea, (MEM_EEPROM_START + 0x01eau), (MEM_EEPROM_START + 0x01eau), 0xff00u,  8U, 1U, 0U, 0x0000u
/** O_HVI_H - Offset of High-voltage input HVI/26 at mid temp */
#define EE_O_HVI_H \
    ee0x5ea, (MEM_EEPROM_START + 0x01eau), (MEM_EEPROM_START + 0x01eau), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM30 - application specific calibration information */
#define EE_APP_TRIM30 \
    ee0x5ec, (MEM_EEPROM_START + 0x01ecu), (MEM_EEPROM_START + 0x01ecu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAIN_LVI_L - Gain of Low-voltage input LVI/2.5 at mid temp */
#define EE_GAIN_LVI_L \
    ee0x5ec, (MEM_EEPROM_START + 0x01ecu), (MEM_EEPROM_START + 0x01ecu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINHI_LVI - Gain-change of Low-voltage input over high temperature range */
#define EE_GAINHI_LVI \
    ee0x5ec, (MEM_EEPROM_START + 0x01ecu), (MEM_EEPROM_START + 0x01ecu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM31 - application specific calibration information */
#define EE_APP_TRIM31 \
    ee0x5ee, (MEM_EEPROM_START + 0x01eeu), (MEM_EEPROM_START + 0x01eeu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_LVI - Offset of Low-voltage input LVI/2.5 at mid temp */
#define EE_O_LVI \
    ee0x5ee, (MEM_EEPROM_START + 0x01eeu), (MEM_EEPROM_START + 0x01eeu), 0xfff0u,  4U, 1U, 0U, 0x0000u
/** GAIN_LVI_H - Gain of Low-voltage input LVI/2.5 at mid temp */
#define EE_GAIN_LVI_H \
    ee0x5ee, (MEM_EEPROM_START + 0x01eeu), (MEM_EEPROM_START + 0x01eeu), 0x000fu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM32 - application specific calibration information */
#define EE_APP_TRIM32 \
    ee0x5f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_TRIM0 - lock bit */
#define EE_LOCK_TRIM0 \
    ee0x5f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** ADC_BLOCK_BYPASSBUF - bypass ADC input buffer */
#define EE_ADC_BLOCK_BYPASSBUF \
    ee0x5f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0x2000u, 13U, 1U, 0U, 0x0000u
/** ADC_BLOCK_INTERCHOP - enable chopping of internal ADC reference */
#define EE_ADC_BLOCK_INTERCHOP \
    ee0x5f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0x1000u, 12U, 1U, 0U, 0x0000u
/** ADC_BLOCK_LATCHCTRL - comparator latch definition */
#define EE_ADC_BLOCK_LATCHCTRL \
    ee0x5f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0x0800u, 11U, 1U, 0U, 0x0000u
/** ADC_INTREF_TRM - reference voltage selection, 3=>Vintref=1.51V, this is the default for 8134x */
#define EE_ADC_INTREF_TRM \
    ee0x5f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0x0700u,  8U, 1U, 0U, 0x0000u
/** TRIM_SDAFILT_IO - I2C SDA filtertrimming */
#define EE_TRIM_SDAFILT_IO \
    ee0x5f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0x00c0u,  6U, 1U, 0U, 0x0000u
/** TRIM_OTD - Overtemperature detection trimming */
#define EE_TRIM_OTD \
    ee0x5f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM33 - application specific calibration information */
#define EE_APP_TRIM33 \
    ee0x5f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_TRIM1 - lock bit */
#define EE_LOCK_TRIM1 \
    ee0x5f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** TR_IO_OCD - trimming overcurrent IO3/4 */
#define EE_TR_IO_OCD \
    ee0x5f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0x2000u, 13U, 1U, 0U, 0x0000u
/** TR_OCVDDA - trimming overcurrent VDDA */
#define EE_TR_OCVDDA \
    ee0x5f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0x1000u, 12U, 1U, 0U, 0x0000u
/** CNT_IILD - internal dead time */
#define EE_CNT_IILD \
    ee0x5f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0x0f00u,  8U, 1U, 0U, 0x0000u
/** TR_CP - trimming of the charge pump voltage */
#define EE_TR_CP \
    ee0x5f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0x00f0u,  4U, 1U, 0U, 0x0000u
/** TR_RCO50K - trimming of the 50k charge pump clock */
#define EE_TR_RCO50K \
    ee0x5f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0x000fu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM34 - application specific calibration information */
#define EE_APP_TRIM34 \
    ee0x5f4, (MEM_EEPROM_START + 0x01f4u), (MEM_EEPROM_START + 0x01f4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** OOCS - offset of the overcurrent DAC */
#define EE_OOCS \
    ee0x5f4, (MEM_EEPROM_START + 0x01f4u), (MEM_EEPROM_START + 0x01f4u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GOCS - gain of the overcurrent DAC */
#define EE_GOCS \
    ee0x5f4, (MEM_EEPROM_START + 0x01f4u), (MEM_EEPROM_START + 0x01f4u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM35 - application specific calibration information */
#define EE_APP_TRIM35 \
    ee0x5f6, (MEM_EEPROM_START + 0x01f6u), (MEM_EEPROM_START + 0x01f6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** USER_EE - word for user purposes */
#define EE_USER_EE \
    ee0x5f6, (MEM_EEPROM_START + 0x01f6u), (MEM_EEPROM_START + 0x01f6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM36 - speed7 reserved for additional speed settings */
#define EE_APP_TRIM36 \
    ee0x5f8, (MEM_EEPROM_START + 0x01f8u), (MEM_EEPROM_START + 0x01f8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SPEED7 - speed7 reserved for additional speed settings */
#define EE_SPEED7 \
    ee0x5f8, (MEM_EEPROM_START + 0x01f8u), (MEM_EEPROM_START + 0x01f8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINHI_VBOOST_64 - Gain-change of input VBOOST/64 over high temperature range */
#define EE_GAINHI_VBOOST_64 \
    ee0x5f8, (MEM_EEPROM_START + 0x01f8u), (MEM_EEPROM_START + 0x01f8u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINLO_VBOOST_64 - Gain-change of input VBOOST/64 over low temperature range */
#define EE_GAINLO_VBOOST_64 \
    ee0x5f8, (MEM_EEPROM_START + 0x01f8u), (MEM_EEPROM_START + 0x01f8u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM37 - speed6 reserved for additional speed settings */
#define EE_APP_TRIM37 \
    ee0x5fa, (MEM_EEPROM_START + 0x01fau), (MEM_EEPROM_START + 0x01fau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SPEED6 - speed6 reserved for additional speed settings */
#define EE_SPEED6 \
    ee0x5fa, (MEM_EEPROM_START + 0x01fau), (MEM_EEPROM_START + 0x01fau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_VBOOST_64_L - Offset of input VBOOST/64 at mid temp */
#define EE_O_VBOOST_64_L \
    ee0x5fa, (MEM_EEPROM_START + 0x01fau), (MEM_EEPROM_START + 0x01fau), 0xf000u, 12U, 1U, 0U, 0x0000u
/** GAIN_VBOOST_64 - Gain of input VBOOST/64 at mid temp */
#define EE_GAIN_VBOOST_64 \
    ee0x5fa, (MEM_EEPROM_START + 0x01fau), (MEM_EEPROM_START + 0x01fau), 0x0fffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM38 - speed5 reserved for additional speed settings */
#define EE_APP_TRIM38 \
    ee0x5fc, (MEM_EEPROM_START + 0x01fcu), (MEM_EEPROM_START + 0x01fcu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SPEED5 - speed5 reserved for additional speed settings */
#define EE_SPEED5 \
    ee0x5fc, (MEM_EEPROM_START + 0x01fcu), (MEM_EEPROM_START + 0x01fcu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM39 - speed4 setting for 32MHz/16MHz with 2 flash wait states */
#define EE_APP_TRIM39 \
    ee0x5fe, (MEM_EEPROM_START + 0x01feu), (MEM_EEPROM_START + 0x01feu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SPEED4 - speed4 setting for 32MHz/16MHz with 2 flash wait states */
#define EE_SPEED4 \
    ee0x5fe, (MEM_EEPROM_START + 0x01feu), (MEM_EEPROM_START + 0x01feu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MELEXIS_TRIM_CRC - Melexis Trimming - CRC location */
#define EE_MELEXIS_TRIM_CRC \
    ee0x600, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** ROM_CONFIGURATION - ROM_CONFIGURATION byte used by ROM code, function is project specific */
#define EE_ROM_CONFIGURATION \
    ee0x600, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** CRC_CS - CRC checksum of config sector */
#define EE_CRC_CS \
    ee0x600, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** IGNORE_RSTAT_FOR_WARM_BOOT - define if RSTAT bit shall be considered for application startup */
#define EE_IGNORE_RSTAT_FOR_WARM_BOOT \
    ee0x600, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0x0800u, 11U, 1U, 0U, 0x0000u
/** FASTLIN_5V - define if fast 5V receiver is used for FASTLIN */
#define EE_FASTLIN_5V \
    ee0x600, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0x0400u, 10U, 1U, 0U, 0x0000u
/** PPM_5V - define if fast 5V receiver is used for PPM */
#define EE_PPM_5V \
    ee0x600, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0x0200u,  9U, 1U, 0U, 0x0000u
/** DISTERM - define if LIN termination is connected */
#define EE_DISTERM \
    ee0x600, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0x0100u,  8U, 1U, 0U, 0x0000u
/** MS_TRIM0 - trim_bg_bias (bandgap, bias) */
#define EE_MS_TRIM0 \
    ee0x602, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_MS_TRIM0 - lock bit of trim port */
#define EE_LOCK_MS_TRIM0 \
    ee0x602, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** MS_TR_BIAS - trim bias source */
#define EE_MS_TR_BIAS \
    ee0x602, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0x3f00u,  8U, 1U, 0U, 0x0000u
/** MS_TR_BGD - trim digital bandgap */
#define EE_MS_TR_BGD \
    ee0x602, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0x00f0u,  4U, 1U, 0U, 0x0000u
/** MS_TR_BGA - trim analog bandgap */
#define EE_MS_TR_BGA \
    ee0x602, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0x000fu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM1 - trim_vdd (tr_sup, vddd, vdda) */
#define EE_MS_TRIM1 \
    ee0x604, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_MS_TRIM1 - lock bit of trim port */
#define EE_LOCK_MS_TRIM1 \
    ee0x604, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** MS_TR_SUP - trim support bits, if used application shall copy them into the port */
#define EE_MS_TR_SUP \
    ee0x604, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0x3fc0u,  6U, 1U, 0U, 0x0000u
/** MS_TR_VDDD - digital supply trimming */
#define EE_MS_TR_VDDD \
    ee0x604, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0x0038u,  3U, 1U, 0U, 0x0000u
/** MS_TR_VDDA - analog supply trimming */
#define EE_MS_TR_VDDA \
    ee0x604, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0x0007u,  0U, 1U, 0U, 0x0000u
/** MS_TRIM2 - trim_rco1m_lin (1MHz RCO, LIN) */
#define EE_MS_TRIM2 \
    ee0x606, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_MS_TRIM2 - lock bit of trim port */
#define EE_LOCK_MS_TRIM2 \
    ee0x606, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** MS_TR_LIN_SLVTERM - LIN slave termination trimming */
#define EE_MS_TR_LIN_SLVTERM \
    ee0x606, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0x3800u, 11U, 1U, 0U, 0x0000u
/** MS_TR_LIN_SLEWRATE - LIN slewrate trimming */
#define EE_MS_TR_LIN_SLEWRATE \
    ee0x606, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0x0700u,  8U, 1U, 0U, 0x0000u
/** MS_TR_RCO1M - RCO 1MHz trimming */
#define EE_MS_TR_RCO1M \
    ee0x606, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM3 - SAR ADC: adc_sar_tr_adcref1 ((ADC refs 1+2); ECADC: Calibration factor CORR[15:0] */
#define EE_MS_TRIM3 \
    ee0x608, (MEM_EEPROM_START + 0x0208u), (MEM_EEPROM_START + 0x0208u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TR_ADCREF2 - Option SAR ADC: reference trimming for xxx V */
#define EE_TR_ADCREF2 \
    ee0x608, (MEM_EEPROM_START + 0x0208u), (MEM_EEPROM_START + 0x0208u), 0x3f80u,  7U, 1U, 0U, 0x0000u
/** TR_ADCREF1 - Option SAR ADC:  reference trimming for xxx V, */
#define EE_TR_ADCREF1 \
    ee0x608, (MEM_EEPROM_START + 0x0208u), (MEM_EEPROM_START + 0x0208u), 0x007fu,  0U, 1U, 0U, 0x0000u
/** CORR_15_0 - Option ECADC: Calibration bits CORR[15:0] */
#define EE_CORR_15_0 \
    ee0x608, (MEM_EEPROM_START + 0x0208u), (MEM_EEPROM_START + 0x0208u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM4 - SAR ADC: adc_sar_tr_adcref3 (ADC ref 3); ECADC: Calibration factor CORR[31:16] */
#define EE_MS_TRIM4 \
    ee0x60a, (MEM_EEPROM_START + 0x020au), (MEM_EEPROM_START + 0x020au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TR_ADCREF3 - Option SAR ADC: reference trimming for xxx V */
#define EE_TR_ADCREF3 \
    ee0x60a, (MEM_EEPROM_START + 0x020au), (MEM_EEPROM_START + 0x020au), 0x007fu,  0U, 1U, 0U, 0x0000u
/** CORR_31_16 - Option ECADC: Calibration bits CORR[31:16] */
#define EE_CORR_31_16 \
    ee0x60a, (MEM_EEPROM_START + 0x020au), (MEM_EEPROM_START + 0x020au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM5 - SAR ADC: trim_vdd_ext (second regulator vddio) ; ECADC: Calibration factor CORR[46:32] */
#define EE_MS_TRIM5 \
    ee0x60c, (MEM_EEPROM_START + 0x020cu), (MEM_EEPROM_START + 0x020cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_MS_TRIM5 - Option SAR ADC - lock bit of trim port, not used for ECADC */
#define EE_LOCK_MS_TRIM5 \
    ee0x60c, (MEM_EEPROM_START + 0x020cu), (MEM_EEPROM_START + 0x020cu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** MS_TR_VDDIO - Option SAR ADC - trimming for second regulator 5V */
#define EE_MS_TR_VDDIO \
    ee0x60c, (MEM_EEPROM_START + 0x020cu), (MEM_EEPROM_START + 0x020cu), 0x0007u,  0U, 1U, 0U, 0x0000u
/** CORR_46_32 - Option ECADC: Calibration bits CORR[46:32] */
#define EE_CORR_46_32 \
    ee0x60c, (MEM_EEPROM_START + 0x020cu), (MEM_EEPROM_START + 0x020cu), 0x7fffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM6 - speed1 setting for 24/12 MHz */
#define EE_MS_TRIM6 \
    ee0x60e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_AC_SL_WAIT_OPTION_SPEED1 - SPEED1 - RCO trimming, 24/12MHz, ac_sl option for ee wait states */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED1 \
    ee0x60e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_AC_SL_WAIT_OPTION_SPEED1 - ac_sl option for flash wait states */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED1 \
    ee0x60e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x4000u, 14U, 1U, 0U, 0x0000u
/** FL_WAIT_STATES_P_SPEED1 - encoded flash wait states, (values {0,1,2,3} map to FL_WAIT_STATES=FL_AC_ SL_OPTION? {1,2,3,4} : {1,1,2,3} ) */
#define EE_FL_WAIT_STATES_P_SPEED1 \
    ee0x60e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x3000u, 12U, 1U, 0U, 0x0000u
/** EE_WAIT_STATES_P_SPEED1 - encoded ee wait states, (values {0,1,2,3} map to EE_WAIT_STATES=EE_AC_ SL_OPTION? {4,5,6,7} : {3,4,5,6} ) */
#define EE_EE_WAIT_STATES_P_SPEED1 \
    ee0x60e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x0c00u, 10U, 1U, 0U, 0x0000u
/** TR_RCO32M_IN_SPEED1 - RC oscillator trim code */
#define EE_TR_RCO32M_IN_SPEED1 \
    ee0x60e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x03ffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM7 - speed2 setting for 28/14 MHz */
#define EE_MS_TRIM7 \
    ee0x610, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_AC_SL_WAIT_OPTION_SPEED2 - SPEED2 - RCO trimming, 28/14MHz */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED2 \
    ee0x610, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_AC_SL_WAIT_OPTION_SPEED2 -  */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED2 \
    ee0x610, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x4000u, 14U, 1U, 0U, 0x0000u
/** FL_WAIT_STATES_P_SPEED2 -  */
#define EE_FL_WAIT_STATES_P_SPEED2 \
    ee0x610, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x3000u, 12U, 1U, 0U, 0x0000u
/** EE_WAIT_STATES_P_SPEED2 -  */
#define EE_EE_WAIT_STATES_P_SPEED2 \
    ee0x610, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x0c00u, 10U, 1U, 0U, 0x0000u
/** TR_RCO32M_IN_SPEED2 -  */
#define EE_TR_RCO32M_IN_SPEED2 \
    ee0x610, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x03ffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM8 - speed3 setting for 32/16 MHz */
#define EE_MS_TRIM8 \
    ee0x612, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_AC_SL_WAIT_OPTION_SPEED3 - SPEED3 - RCO trimming, 32/16MHz */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED3 \
    ee0x612, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_AC_SL_WAIT_OPTION_SPEED3 -  */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED3 \
    ee0x612, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x4000u, 14U, 1U, 0U, 0x0000u
/** FL_WAIT_STATES_P_SPEED3 -  */
#define EE_FL_WAIT_STATES_P_SPEED3 \
    ee0x612, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x3000u, 12U, 1U, 0U, 0x0000u
/** EE_WAIT_STATES_P_SPEED3 -  */
#define EE_EE_WAIT_STATES_P_SPEED3 \
    ee0x612, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x0c00u, 10U, 1U, 0U, 0x0000u
/** TR_RCO32M_IN_SPEED3 -  */
#define EE_TR_RCO32M_IN_SPEED3 \
    ee0x612, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x03ffu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM0 - R2_EE */
#define EE_NV_TRIM0 \
    ee0x614, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R2_EE - R2_EE */
#define EE_R2_EE \
    ee0x614, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TSENSE - Sense time settings */
#define EE_TSENSE \
    ee0x614, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x7000u, 12U, 1U, 0U, 0x0000u
/** TRDY - Ready signal delay settings */
#define EE_TRDY \
    ee0x614, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0c00u, 10U, 1U, 0U, 0x0000u
/** TPRE - Precharge delay settings */
#define EE_TPRE \
    ee0x614, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0300u,  8U, 1U, 0U, 0x0000u
/** EN_VMG - VMG voltage to memory gates */
#define EE_EN_VMG \
    ee0x614, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0080u,  7U, 1U, 0U, 0x0000u
/** EN_VMG_CT - enable VMGM margin voltage at CSA */
#define EE_EN_VMG_CT \
    ee0x614, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0040u,  6U, 1U, 0U, 0x0000u
/** EN_VMG_TT - enable VMGM margin voltage at MSA */
#define EE_EN_VMG_TT \
    ee0x614, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0020u,  5U, 1U, 0U, 0x0000u
/** SW_VMGM_EE - VMG margin voltage (VMGM) */
#define EE_SW_VMGM_EE \
    ee0x614, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x001fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM1 - R1_EE */
#define EE_NV_TRIM1 \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R1_EE - R1_EE */
#define EE_R1_EE \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** REG_1_RES - register, reserve */
#define EE_REG_1_RES \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** CP_CLK_DIV - CP clock divider */
#define EE_CP_CLK_DIV \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x6000u, 13U, 1U, 0U, 0x0000u
/** EE_CP_SC_FL - disable second CP chain */
#define EE_EE_CP_SC_FL \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x1000u, 12U, 1U, 0U, 0x0000u
/** SEL_ODD - select odd cells in CS / MA */
#define EE_SEL_ODD \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x0800u, 11U, 1U, 0U, 0x0000u
/** SEL_EVEN - select even cells in CS / MA */
#define EE_SEL_EVEN \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x0400u, 10U, 1U, 0U, 0x0000u
/** SEL_CS - select CS */
#define EE_SEL_CS \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x0200u,  9U, 1U, 0U, 0x0000u
/** SEL_MA - select MA */
#define EE_SEL_MA \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x0100u,  8U, 1U, 0U, 0x0000u
/** TR_PCP1_W_EE - EEPROM program voltage */
#define EE_TR_PCP1_W_EE \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x00f0u,  4U, 1U, 0U, 0x0000u
/** TR_PCP1_E_EE - EEPROM erase voltage */
#define EE_TR_PCP1_E_EE \
    ee0x616, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x000fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM2 - R3_FL */
#define EE_NV_TRIM2 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R3_FL - R3_FL */
#define EE_R3_FL \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SW_VCTAT - Flash 32k : SW_VCTAT[1:0], set VCTAT voltage */
#define EE_SW_VCTAT \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0xc000u, 14U, 1U, 0U, 0x0000u
/** VCTAT_EN - Flash 32k : VCTAT_EN  - activate VCTAT voltage; */
#define EE_VCTAT_EN \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x2000u, 13U, 1U, 0U, 0x0000u
/** EN_IREF1_BL - Flash 32k : EN_IREF1_BL  -  Enable pmos reference current (BL); */
#define EE_EN_IREF1_BL \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x1000u, 12U, 1U, 0U, 0x0000u
/** EN_IREF1_BLR - Flash 32k : EN_IREF1_BLR  -  Enable pmos reference current (BLR); */
#define EE_EN_IREF1_BLR \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0800u, 11U, 1U, 0U, 0x0000u
/** VPTAT_EN - Flash 32k: VPTAT_EN  -  Enable VPTAT voltage; */
#define EE_VPTAT_EN \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0400u, 10U, 1U, 0U, 0x0000u
/** YD - Flash 32k: Enable dummy bitline 1:0 */
#define EE_YD \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0300u,  8U, 1U, 0U, 0x0000u
/** BLRES_ENA_1 - Flash 32k : BLRES_ENA[1]  -  Enable bitline reset; */
#define EE_BLRES_ENA_1 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0080u,  7U, 1U, 0U, 0x0000u
/** TSEN - Flash 32K : TSEN - Sense time; */
#define EE_TSEN \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0070u,  4U, 1U, 0U, 0x0000u
/** BLRES_ENA_0 - Flash 32k : BLRES_ENA[0] - Enable bitline reset; */
#define EE_BLRES_ENA_0 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0008u,  3U, 1U, 0U, 0x0000u
/** TPRECH - Flash 32k : TPRECH - Pre-charge time; */
#define EE_TPRECH \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0007u,  0U, 1U, 0U, 0x0000u
/** SW_VCTAT_64 - Flash 64k : SW_VCTAT[3:0], set VCTAT voltage */
#define EE_SW_VCTAT_64 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0xf000u, 12U, 1U, 0U, 0x0000u
/** EN_IREF_BL_64 - Flash 64k : EN_IREF_BL  -  Enable pmos reference current (BL); */
#define EE_EN_IREF_BL_64 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0800u, 11U, 1U, 0U, 0x0000u
/** EN_IREF_BLR_64 - Flash 64k : EN_IREF_BLR  -  Enable pmos reference current (BLR); */
#define EE_EN_IREF_BLR_64 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0400u, 10U, 1U, 0U, 0x0000u
/** YD_64 - Flash 64k: Enable dummy bitline 1:0 */
#define EE_YD_64 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0300u,  8U, 1U, 0U, 0x0000u
/** TSEN_64 - Flash 64k : TSEN - Sense time */
#define EE_TSEN_64 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x00e0u,  5U, 1U, 0U, 0x0000u
/** TPRECH_64 - Flash 64k : TPRECH - Pre-charge time; */
#define EE_TPRECH_64 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x001cu,  2U, 1U, 0U, 0x0000u
/** TINIT_64 - Flash 64k : TINIT - Init read timing */
#define EE_TINIT_64 \
    ee0x618, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0003u,  0U, 1U, 0U, 0x0000u
/** NV_TRIM3 - R2_FL */
#define EE_NV_TRIM3 \
    ee0x61a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R2_FL - R2_FL */
#define EE_R2_FL \
    ee0x61a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** T_MEAS - Flash 32k: T_MEAS[3:0]; Flash 64k: T_MEAS[4:1] - measurement test modes */
#define EE_T_MEAS \
    ee0x61a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0xf000u, 12U, 1U, 0U, 0x0000u
/** SW_IREF_X2 - Flash 32k: double IREF for margin mode; Flash 64k: T_MEAS[0] */
#define EE_SW_IREF_X2 \
    ee0x61a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0x0800u, 11U, 1U, 0U, 0x0000u
/** SW_IREF - set IREF for margin mode */
#define EE_SW_IREF \
    ee0x61a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0x07e0u,  5U, 1U, 0U, 0x0000u
/** SW_VMG - VMG voltage Flash and EEPROM */
#define EE_SW_VMG \
    ee0x61a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0x001fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM4 - R1_FL */
#define EE_NV_TRIM4 \
    ee0x61c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R1_FL - R1_FL */
#define EE_R1_FL \
    ee0x61c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** DIS_ALL_MG - disable all MG */
#define EE_DIS_ALL_MG \
    ee0x61c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** WNV_MODE - write modes */
#define EE_WNV_MODE \
    ee0x61c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x7000u, 12U, 1U, 0U, 0x0000u
/** CP_DIS_SG - disable SG CP */
#define EE_CP_DIS_SG \
    ee0x61c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x0800u, 11U, 1U, 0U, 0x0000u
/** CP_SC_FL - disable second CP chain */
#define EE_CP_SC_FL \
    ee0x61c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x0400u, 10U, 1U, 0U, 0x0000u
/** ERA_MODE - erase modes */
#define EE_ERA_MODE \
    ee0x61c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x0300u,  8U, 1U, 0U, 0x0000u
/** TR_PCP1_W_FL - Flash program voltage */
#define EE_TR_PCP1_W_FL \
    ee0x61c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x00f0u,  4U, 1U, 0U, 0x0000u
/** TR_PCP1_E_FL - Flash Erase voltage */
#define EE_TR_PCP1_E_FL \
    ee0x61c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x000fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM5 - EEPROM read timing port */
#define EE_NV_TRIM5 \
    ee0x61e, (MEM_EEPROM_START + 0x021eu), (MEM_EEPROM_START + 0x021eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_LOCK_RD - lock this port */
#define EE_EE_LOCK_RD \
    ee0x61e, (MEM_EEPROM_START + 0x021eu), (MEM_EEPROM_START + 0x021eu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** EE_WAIT_STATES
 * (EE_WAIT_STATES +1) is the number of clock pulses to have a stable read data
 * Ready delay = (EE_WAIT_STATES + 2) * MCU_CLK
 */
#define EE_EE_WAIT_STATES \
    ee0x61e, (MEM_EEPROM_START + 0x021eu), (MEM_EEPROM_START + 0x021eu), 0x0f00u,  8U, 1U, 0U, 0x0000u
/** EE_HALT_BEHAVIOR - Define the EEPROM behavior when application is halted */
#define EE_EE_HALT_BEHAVIOR \
    ee0x61e, (MEM_EEPROM_START + 0x021eu), (MEM_EEPROM_START + 0x021eu), 0x0003u,  0U, 1U, 0U, 0x0000u
/** NV_TRIM6 - EEPROM program cycle port */
#define EE_NV_TRIM6 \
    ee0x620, (MEM_EEPROM_START + 0x0220u), (MEM_EEPROM_START + 0x0220u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_PROGRAM_CYCLE_LOCK - lock this port */
#define EE_EE_PROGRAM_CYCLE_LOCK \
    ee0x620, (MEM_EEPROM_START + 0x0220u), (MEM_EEPROM_START + 0x0220u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** EE_PROGRAM_CYCLE
 * This field defined the number of program cycles needed for writing a word in the EEPROM
 * Number of program cycles = EE_PROGRAM_CYCLE + 1
 */
#define EE_EE_PROGRAM_CYCLE \
    ee0x620, (MEM_EEPROM_START + 0x0220u), (MEM_EEPROM_START + 0x0220u), 0x001fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM7 - EEPROM erase timing */
#define EE_NV_TRIM7 \
    ee0x622, (MEM_EEPROM_START + 0x0222u), (MEM_EEPROM_START + 0x0222u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_LOCK_ER - lock this port */
#define EE_EE_LOCK_ER \
    ee0x622, (MEM_EEPROM_START + 0x0222u), (MEM_EEPROM_START + 0x0222u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** EE_ER_TIME - Erase time = (EE_ER_TIME + 1) * 100us */
#define EE_EE_ER_TIME \
    ee0x622, (MEM_EEPROM_START + 0x0222u), (MEM_EEPROM_START + 0x0222u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM8 - EEPROM write timing */
#define EE_NV_TRIM8 \
    ee0x624, (MEM_EEPROM_START + 0x0224u), (MEM_EEPROM_START + 0x0224u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_LOCK_WR - lock this port */
#define EE_EE_LOCK_WR \
    ee0x624, (MEM_EEPROM_START + 0x0224u), (MEM_EEPROM_START + 0x0224u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** EE_WR_TIME - Write time = (EE_WR_TIME + 1) * 10us */
#define EE_EE_WR_TIME \
    ee0x624, (MEM_EEPROM_START + 0x0224u), (MEM_EEPROM_START + 0x0224u), 0x7f00u,  8U, 1U, 0U, 0x0000u
/** EE_PRE_WR_TIME - Pre-Write time = (EE_PRE_WR_TIME + 1) * 10us */
#define EE_EE_PRE_WR_TIME \
    ee0x624, (MEM_EEPROM_START + 0x0224u), (MEM_EEPROM_START + 0x0224u), 0x007fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM9 - Flash read configuration word */
#define EE_NV_TRIM9 \
    ee0x626, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** FL_LOCK_RDY - lock this port */
#define EE_FL_LOCK_RDY \
    ee0x626, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_HALT_BEHAVIOR - Define the flash behavior when application is halted */
#define EE_FL_HALT_BEHAVIOR \
    ee0x626, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x3000u, 12U, 1U, 0U, 0x0000u
/** FL_DED_RETRY - number of re-try in case of Double Error Detect (DED) */
#define EE_FL_DED_RETRY \
    ee0x626, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x0700u,  8U, 1U, 0U, 0x0000u
/** FL_PREDICTION_BEHAVIOR - Define the behavior of the flash prediction */
#define EE_FL_PREDICTION_BEHAVIOR \
    ee0x626, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x00c0u,  6U, 1U, 0U, 0x0000u
/** FL_BYPASS_QUEUE - Define if Queue is used */
#define EE_FL_BYPASS_QUEUE \
    ee0x626, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x0010u,  4U, 1U, 0U, 0x0000u
/** FL_WAIT_STATES - Number of clock pulses between the read access start and the wishbone READY rising edge. */
#define EE_FL_WAIT_STATES \
    ee0x626, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x0007u,  0U, 1U, 0U, 0x0000u
/** NV_TRIM10 - Flash erase/write timing */
#define EE_NV_TRIM10 \
    ee0x628, (MEM_EEPROM_START + 0x0228u), (MEM_EEPROM_START + 0x0228u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** FL_LOCK_ER_WR - lock this port */
#define EE_FL_LOCK_ER_WR \
    ee0x628, (MEM_EEPROM_START + 0x0228u), (MEM_EEPROM_START + 0x0228u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_WR_TIME - Write time = (FL_WR_TIME + 1) * 100us */
#define EE_FL_WR_TIME \
    ee0x628, (MEM_EEPROM_START + 0x0228u), (MEM_EEPROM_START + 0x0228u), 0x7f00u,  8U, 1U, 0U, 0x0000u
/** FL_ER_TIME - Erase time = (FL_ER_TIME + 1) * 100us */
#define EE_FL_ER_TIME \
    ee0x628, (MEM_EEPROM_START + 0x0228u), (MEM_EEPROM_START + 0x0228u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM11 - Timing Port2 */
#define EE_NV_TRIM11 \
    ee0x62a, (MEM_EEPROM_START + 0x022au), (MEM_EEPROM_START + 0x022au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_T_1US - lock this port */
#define EE_LOCK_T_1US \
    ee0x62a, (MEM_EEPROM_START + 0x022au), (MEM_EEPROM_START + 0x022au), 0x8000u, 15U, 1U, 0U, 0x0000u
/** R3_FL_FLASH_15_13 - R3_FL[15:13] = VCTAT enable for flash (starting from Flash 1.4) */
#define EE_R3_FL_FLASH_15_13 \
    ee0x62a, (MEM_EEPROM_START + 0x022au), (MEM_EEPROM_START + 0x022au), 0x0e00u,  9U, 1U, 0U, 0x0000u
/** T_1US - control the 1us time in the flash shell */
#define EE_T_1US \
    ee0x62a, (MEM_EEPROM_START + 0x022au), (MEM_EEPROM_START + 0x022au), 0x001fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM12 - Timing Port1 */
#define EE_NV_TRIM12 \
    ee0x62c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_T - lock this port */
#define EE_LOCK_T \
    ee0x62c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** T_50US - control the 50us time in the flash shell */
#define EE_T_50US \
    ee0x62c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x7c00u, 10U, 1U, 0U, 0x0000u
/** T_10US - control the 10us time in the flash shell */
#define EE_T_10US \
    ee0x62c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x03e0u,  5U, 1U, 0U, 0x0000u
/** T_50NS - control the 50ns time in the flash shell */
#define EE_T_50NS \
    ee0x62c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x001cu,  2U, 1U, 0U, 0x0000u
/** T_10NS - control the 10ns time in the flash shell */
#define EE_T_10NS \
    ee0x62c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x0001u,  0U, 1U, 0U, 0x0000u
/** NV_TRIM13 - NV memory, open */
#define EE_NV_TRIM13 \
    ee0x62e, (MEM_EEPROM_START + 0x022eu), (MEM_EEPROM_START + 0x022eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** CHIPID0 - Chip ID0 readable by application - copy of MLX TestChipId0 */
#define EE_CHIPID0 \
    ee0x630, (MEM_EEPROM_START + 0x0230u), (MEM_EEPROM_START + 0x0230u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_D_YPOS_ID - Copy of TEST_CHIP_ID0 */
#define EE_APP_D_YPOS_ID \
    ee0x630, (MEM_EEPROM_START + 0x0230u), (MEM_EEPROM_START + 0x0230u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** APP_D_XPOS_ID - Copy of TEST_CHIP_ID0 */
#define EE_APP_D_XPOS_ID \
    ee0x630, (MEM_EEPROM_START + 0x0230u), (MEM_EEPROM_START + 0x0230u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** CHIPID1 - Chip ID1 readable by application - copy of MLX TestChipId1 */
#define EE_CHIPID1 \
    ee0x632, (MEM_EEPROM_START + 0x0232u), (MEM_EEPROM_START + 0x0232u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_D_LOT_ID_H - Copy of TEST_CHIP_ID1 */
#define EE_APP_D_LOT_ID_H \
    ee0x632, (MEM_EEPROM_START + 0x0232u), (MEM_EEPROM_START + 0x0232u), 0xffe0u,  5U, 1U, 0U, 0x0000u
/** APP_D_WFR_ID - Copy of TEST_CHIP_ID1 */
#define EE_APP_D_WFR_ID \
    ee0x632, (MEM_EEPROM_START + 0x0232u), (MEM_EEPROM_START + 0x0232u), 0x001fu,  0U, 1U, 0U, 0x0000u
/** CHIPID2 - Copy of TEST_CHIP_ID2 */
#define EE_CHIPID2 \
    ee0x634, (MEM_EEPROM_START + 0x0234u), (MEM_EEPROM_START + 0x0234u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_D_CORDAT6_ID - Chip ID2 readable by application - copy of MLX TestChipId2 */
#define EE_APP_D_CORDAT6_ID \
    ee0x634, (MEM_EEPROM_START + 0x0234u), (MEM_EEPROM_START + 0x0234u), 0xfc00u, 10U, 1U, 0U, 0x0000u
/** APP_D_FAB_ID - Copy of TEST_CHIP_ID2 */
#define EE_APP_D_FAB_ID \
    ee0x634, (MEM_EEPROM_START + 0x0234u), (MEM_EEPROM_START + 0x0234u), 0x03c0u,  6U, 1U, 0U, 0x0000u
/** APP_D_LOT_ID_L - Copy of TEST_CHIP_ID2 */
#define EE_APP_D_LOT_ID_L \
    ee0x634, (MEM_EEPROM_START + 0x0234u), (MEM_EEPROM_START + 0x0234u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** PROJECT_ID - Copy of Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_PROJECT_ID \
    ee0x636, (MEM_EEPROM_START + 0x0236u), (MEM_EEPROM_START + 0x0236u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** CHIPID3 - Copy of TEST_CHIP_ID3 */
#define EE_CHIPID3 \
    ee0x636, (MEM_EEPROM_START + 0x0236u), (MEM_EEPROM_START + 0x0236u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_PROJECT_ID - Unique PROJECT_ID for software use */
#define EE_APP_PROJECT_ID \
    ee0x636, (MEM_EEPROM_START + 0x0236u), (MEM_EEPROM_START + 0x0236u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TESTCHIPID0 - MLX TestChipID0 created by test program */
#define EE_TESTCHIPID0 \
    ee0x638, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0xffffu,  0U, 1U, 0U, -0x1f0000u
/** MLX_ID0 - Melexis IC test identification data */
#define EE_MLX_ID0 \
    ee0x638, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0xffffu,  0U, 1U, 0U, -0x1f0000u
/** D_CHIP_ID - Melexis IC test identification data D_CHIP ID[20:0] */
#define EE_D_CHIP_ID \
    ee0x638, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0x1fffffu,  0U, 1U, 0U, -0x1f0000u
/** D_YPOS_ID - Y position */
#define EE_D_YPOS_ID \
    ee0x638, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0xff00u,  8U, 1U, 0U, -0x1f0000u
/** D_XPOS_ID - X position */
#define EE_D_XPOS_ID \
    ee0x638, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0x00ffu,  0U, 1U, 0U, -0x1f0000u
/** TESTCHIPID1 - MLX TestChipId1 created by test program */
#define EE_TESTCHIPID1 \
    ee0x63a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0xffffu,  0U, 1U, 0U, -0x3f0000u
/** MLX_ID1 - Melexis IC test identification data */
#define EE_MLX_ID1 \
    ee0x63a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0xffffu,  0U, 1U, 0U, -0x3f0000u
/** D_LOT_ID - Lot Number */
#define EE_D_LOT_ID \
    ee0x63a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0x3fffe0u,  5U, 1U, 0U, -0x3f0000u
/** D_LOT_ID_LSB11 - Lot Number [10:0] */
#define EE_D_LOT_ID_LSB11 \
    ee0x63a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0xffe0u,  5U, 1U, 0U, -0x3f0000u
/** D_WFR_ID - Wafer number */
#define EE_D_WFR_ID \
    ee0x63a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0x001fu,  0U, 1U, 0U, -0x3f0000u
/** TESTCHIPID2 - MLX TestChipId2 created by test program */
#define EE_TESTCHIPID2 \
    ee0x63c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MLX_ID2 - Melexis IC test identification data */
#define EE_MLX_ID2 \
    ee0x63c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** D_CORDAT_ID - Melexis IC test identification data */
#define EE_D_CORDAT_ID \
    ee0x63c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0xfc00u, 10U, 1U, 0U, 0x0000u
/** D_FAB_ID - FAB id number */
#define EE_D_FAB_ID \
    ee0x63c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0x03c0u,  6U, 1U, 0U, 0x0000u
/** D_LOT_ID_MSB6 - Lot Number [16:11] */
#define EE_D_LOT_ID_MSB6 \
    ee0x63c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0x003fu,  0U, 1U, 0U, 0x0000u
/** TESTCHIPID3 - Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_TESTCHIPID3 \
    ee0x63e, (MEM_EEPROM_START + 0x023eu), (MEM_EEPROM_START + 0x023eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TEST_PROJECT_ID - Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_TEST_PROJECT_ID \
    ee0x63e, (MEM_EEPROM_START + 0x023eu), (MEM_EEPROM_START + 0x023eu), 0xffffu,  0U, 1U, 0U, 0x0000u

/*****************************************************************************/
/* 3.4 Dummy fields. */

/* MlxCCT private. */

#define EE_ \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY2  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY3  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY4  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY5  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY6  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY7  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY8  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY9  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY10  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY11  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY12  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY13  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY14  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY15  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY16  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY17  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U

/*****************************************************************************/
/* 4. Summary. */

/* Report of values which might be of interest. */

/*
 * Range: 0x0400u to 0x063eu
 * Variables: 104
 * Fields: 344
 * Occupation: 36.48% (209.3 bytes)
 */

#endif /* EEPROM_PARAMETERS_H */

/* EOF */
